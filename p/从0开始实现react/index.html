<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Job Interview tips'><title>从0开始实现React</title>

<link rel='canonical' href='https://observerzq.github.io/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/'>

<link rel="stylesheet" href="/ObzerverZQ.github.io/scss/style.min.css"><meta property='og:title' content='从0开始实现React'>
<meta property='og:description' content='Job Interview tips'>
<meta property='og:url' content='https://observerzq.github.io/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/'>
<meta property='og:site_name' content='Observer的小家'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='React' /><meta property='article:published_time' content='2021-03-30T12:20:26&#43;08:00'/><meta property='article:modified_time' content='2021-03-30T12:20:26&#43;08:00'/><meta property='og:image' content='https://observerzq.github.io/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react.jpeg' />
<meta name="twitter:title" content="从0开始实现React">
<meta name="twitter:description" content="Job Interview tips"><meta name="twitter:card" content="">
	<meta name="twitter:image" content='https://observerzq.github.io/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react.jpeg' />
    </head>
    <body class="">
        <div class="container flex on-phone--column align-items--flex-start extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/ObzerverZQ.github.io/img/avatar_huf4d83bafa5838b1714e814874f4f8037_84351_300x0_resize_q75_box.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
                    <span class="emoji">👩🏻‍💻</span>
                
            </figure>
        
        <h1 class="site-name"><a href="https://observerzq.github.io/ObzerverZQ.github.io/">Observer的小家</a></h1>
        <h2 class="site-description">一个前端小白.</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/ObzerverZQ.github.io/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/ObzerverZQ.github.io/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/ObzerverZQ.github.io/post'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>Posts</span>
            </a>
        </li>
        
        

        <li >
            <a href='/ObzerverZQ.github.io/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/ObzerverZQ.github.io/search'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://observerzq.github.io/ObzerverZQ.github.io/" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <img srcset="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react_hu4014157c127633b5f677ff85eb79e346_173734_1024x0_resize_q75_box.jpeg 1024w, /ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react_hu4014157c127633b5f677ff85eb79e346_173734_2000x0_resize_q75_box.jpeg 2000w"
                    src="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react_hu4014157c127633b5f677ff85eb79e346_173734_2000x0_resize_q75_box.jpeg" width="1200" height="638" loading="lazy"
                    alt="Featured image of post 从0开始实现React" />
            
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/ObzerverZQ.github.io/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/" 
                    class="color-tag"
                    data-image="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react_hu4014157c127633b5f677ff85eb79e346_173734_20x20_fill_q75_box_smart1.jpeg" 
                    data-key="" 
                    data-hash="md5-smuMxL6qzvl&#43;OUxTfuxHUg==">
                    框架原理
                </a>
            
        
    </header>
    

    <h2 class="article-title">
        <a href="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/">从0开始实现React</a>
    </h2>

    
    <h3 class="article-subtitle">
        Job Interview tips
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Mar 30, 2021</time>
    </footer></div>
</header>

    <section class="article-content">
    <p>参考：https://pomb.us/build-your-own-react/
基于React 16.8实现，因而可以使用hook，不再书写使用过去的class相关的代码。</p>
<p>实现React的基本思路如下：
Step I: The createElement Function  第一步：创建节点
Step II: The render Function    第二步：渲染
Step III: Concurrent Mode     第三步：concurrent模式
Step IV: Fibers               第四步：Fiber“纤维”
Step V: Render and Commit Phases  第五步： 渲染和Commit阶段
Step VI: Reconciliation           第六步：调和
Step VII: Function Components   第七步：函数组件
Step VIII: Hooks                第八步：Hooks</p>
<h1 id="第0步回顾">第0步：回顾</h1>
<p>下面是最简单的几行React代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">title</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="o">&lt;</span><span class="err">/h1&gt;</span>
<span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">)</span>
<span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="c1">// 把element插入到页面的DOM节点container中
</span></code></pre></div><p>第一行代码替换成vanilla（香草？）JS代码，变化如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// JSX 通过Babel编译成JS
</span><span class="c1">// 一般转换过程都很简单：调用createElement把tag内的代码替换掉，传入tag名，属性和子节点作为参数
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">title</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="o">&lt;</span><span class="err">/h1&gt; </span>
<span class="c1">// ========transformation=========
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
  <span class="s2">&#34;h1&#34;</span><span class="p">,</span>
  <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="s2">&#34;foo&#34;</span> <span class="p">},</span>
  <span class="s2">&#34;Hello&#34;</span>
<span class="p">)</span>
<span class="c1">// React.createElement 根据入参返回一个对象。中间还有一些校验。
</span><span class="c1">// 所以我们可以直接将函数调用替换为函数最终的输出。
</span><span class="c1">// 这就是React中一个element object，包含type和props两个字段（目前我们只关注这两个属性）
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// type是一个字符串，表明我们想要创建的DOM节点的类型，和document.createElement方法中的tagName是一样的。type也可以是一个函数，这个留到第7步再作讲解。
</span><span class="c1"></span>    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;h1&#39;</span><span class="p">,</span>
    <span class="c1">// props是一个对象，它包含所有JSX属性的键值对。它还包含一个特殊的属性children。 
</span><span class="c1"></span>    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
        <span class="c1">// children在这里是一个字符串，但是它通常是一个数组，包含多个element。这也是elements也是树的原因。
</span><span class="c1"></span>        <span class="nx">children</span><span class="o">:</span> <span class="s1">&#39;Hello&#39;</span> 
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>然后还有第3行代码，这是React渲染/修改DOM的地方，现在由我们自己来实现这个更新。</p>
<p>首先我们根据React element的type去创建一个DOM节点node，在这个例子中是h1。
然后我们将element所有的属性prop添加到这个node上，这里暂时只有title。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
<span class="nx">node</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">title</span><span class="p">;</span>
</code></pre></div><p>然后我们为children创建DOM节点。这里只有一个文本作为child，所以我们创建为它创建一个text node。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="c1">// 用textNode而不是设置innerText会允许我们稍后用相同的方式来处理所有的elements。
</span><span class="c1">// 同样要注意我们就像对h1设置title属性一样，对textNode设置nodeValue，就像这个字符串拥有自己的props: {nodeValue: &#34;hello&#34;}似的。
</span><span class="c1"></span><span class="nx">text</span><span class="p">[</span><span class="s1">&#39;nodeValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
</code></pre></div><p>最后，把text添加到h1 node中，把node添加到container中。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">node</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
<span class="nx">container</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
</code></pre></div><p>现在，我们实现了之前依靠React JSX和React.render才实现的功能。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;h1&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
        <span class="nx">children</span><span class="o">:</span> <span class="s1">&#39;Hello&#39;</span> 
    <span class="p">}</span>
<span class="p">};</span>
<span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
<span class="nx">node</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">title</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="nx">text</span><span class="p">[</span><span class="s1">&#39;nodeValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
<span class="nx">node</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
<span class="nx">container</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
</code></pre></div><h1 id="第1步-createelement函数">第1步 createElement函数</h1>
<p>现在，让我们用另一个app重新开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">a</span><span class="o">&gt;</span><span class="nx">bar</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
    <span class="o">&lt;</span><span class="nx">b</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="p">)</span>
<span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">)</span>
<span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span>
</code></pre></div><p>这次我们会用我们自己版本的React去替换原来的React。
我们从实现createElement函数开始。让我们将JSX转换为JS，从而看见createElement的调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
    <span class="s1">&#39;div&#39;</span><span class="p">,</span>
    <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span> <span class="p">},</span>
    <span class="p">[</span>
        <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span>
        <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div><p>正如我们上一步看到的那样，一个element是一个包含type和props两个属性的对象。所以我们的函数只需要执行创建对象的工作。
现在我们来实现createElement函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//我们对props使用...扩展符号，对children使用剩余符号，这样children的值将一定是数组。
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">createElement</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">props</span><span class="p">,</span> <span class="p">...</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">type</span><span class="p">,</span>
        <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
            <span class="p">...</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">children</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>
<span class="c1">// { type: &#39;div&#39;, props: { children: [] } }
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
<span class="c1">// { type: &#39;div&#39;, props: { children: [a] } }
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="c1">// { type: &#39;div&#39;, props: { children: [a, b] } }
</span></code></pre></div><p>children数组也可以包含基本类型，比如字符串或数字。所以我们会将非对象的类型包裹在一个element中，并创建一个特殊type，名叫TEXT_ELEMENT。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createElement</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">props</span><span class="p">,</span> <span class="p">...</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">type</span><span class="p">,</span>
        <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
            <span class="p">...</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">children</span><span class="o">:</span> <span class="nx">children</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">child</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">typeof</span> <span class="nx">child</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">?</span> <span class="nx">child</span> <span class="o">:</span> <span class="nx">createTextElement</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">createTextElement</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;TEXT_ELEMENT&#39;</span><span class="p">,</span>
        <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">nodeValue</span><span class="o">:</span> <span class="nx">text</span><span class="p">,</span>
            <span class="nx">children</span><span class="o">:</span> <span class="p">[]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>注意，React源码并没有像这样包裹基本类型值或在没有children时创建空数组，但我们这样做可以简化代码。对于我们的库，我们更喜欢简单的代码，而非高性能的代码。</p>
<p>上文我们还在用React.createElement。现在，我们用Didact来替换React，表明为我们自己实现的库。目前，让它包含上面刚刚实现的createElement方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Didact</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">createElement</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">Didact</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
    <span class="s1">&#39;div&#39;</span><span class="p">,</span>
    <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span> <span class="p">},</span>
    <span class="p">[</span>
        <span class="nx">Didact</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span>
        <span class="nx">Didact</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div><p>上面是编译后的JS代码。在这之前，我们还是得用JSX。那么我们怎么让babel知道要编译成Didact.createElement而不是React的createElement呢？
像这样注释，当babel编译JSX时它就会用我们定义的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/** @jsx Didact.createElement */</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">a</span><span class="o">&gt;</span><span class="nx">bar</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
    <span class="o">&lt;</span><span class="nx">b</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="p">)</span>
</code></pre></div><h1 id="第2步-render函数">第2步 render函数</h1>
<p>创建好了element，现在我们要实现自己的render函数，将一个object转换为DOM节点并添加到container中：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span>
</code></pre></div><p>现在，我们只关注添加节点到DOM中。我们稍后会再处理update和delete操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Didact</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">createElement</span><span class="p">,</span>
    <span class="nx">render</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO create dom nodes
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// ...jsx
</span><span class="c1">// const container = document.getElementById(&#39;root&#39;)
</span><span class="c1"></span><span class="nx">Didact</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">);</span>
</code></pre></div><p>我们从根据type创建一个DOM node，然后将该node添加到container中开始：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在这里也要对text节点特殊处理，如果type为之前设定的TEXT_ELEMENT，则需要调用createTextNode方法
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;TEXT_ELEMENT&#39;</span> <span class="o">?</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    
    <span class="c1">// 还记得每个element的属性吗？除了children，其余的属性都要绑定到对应的DOM node上
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">isProperty</span> <span class="o">=</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;children&#39;</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isProperty</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="c1">// 然后对element的每个子节点做递归操作，生成DOM node并添加到该element对应的DOM node中，形成真正的DOM树
</span><span class="c1"></span>    <span class="nx">element</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">child</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">render</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">dom</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">container</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">dom</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>完成。现在我们有了一个可以将JSX转译为DOM的库了。https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js</p>
<h1 id="第3步-concurrent模式">第3步 concurrent模式</h1>
<p>在添加更多代码前，我们需要做个重构。上面的forEach render递归调用存在一个问题，就是当element树太大时，它可能会阻断主线程太久。
而且，如果浏览器需要执行高优先级的工作，例如提交用户输入，或者保障动画流畅播放，那么浏览器就要等到它完成渲染。</p>
<p>所以我们要将渲染工作拆分成小的单元，每执行完一个，浏览器发现还有别的是事情要做的话就会中断渲染。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 我们用requestIdleCallback来建立一个循环。你可以把它看作setTimeout，但是不是由我们去告诉它什么时候运行，而是由浏览器在主线程空闲是去执行callback。
</span><span class="c1"></span>
<span class="c1">// React不再使用requestIdleCallback。现在它使用scheduler package。但是在这个用例中它们的概念是类似的。
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="c1">// 入参deadline可以用来检查在浏览器需要重新take control之前我们还有多少时间去执行渲染
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">workLoop</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">shouldYield</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="c1">// 如果还有任务 &amp;&amp; 当前帧还有空闲
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="nx">nextUnitOfWork</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">shouldYield</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">nextUnitOfWork</span><span class="p">);</span>
        <span class="nx">shouldYield</span> <span class="o">=</span> <span class="nx">deadline</span><span class="p">.</span><span class="nx">timeRemaing</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">requestIdleCallback</span><span class="p">(</span><span class="nx">workLoop</span><span class="p">)</span> <span class="c1">// 等待下一帧
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">requestIdleCallback</span><span class="p">(</span><span class="nx">workLoop</span><span class="p">)</span> <span class="c1">// 启动时间切片
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">nextUnitOfWork</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>As of截至2019年11月, Concurrent Mode还没有发布稳定版本。循环的稳定版本更像是下面这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">while</span> <span class="p">(</span><span class="nx">nextUnitOfWork</span><span class="p">)</span> <span class="p">{</span>    
  <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">performUnitOfWork</span><span class="p">(</span>   
    <span class="nx">nextUnitOfWork</span>  
  <span class="p">)</span> 
<span class="p">}</span>
</code></pre></div><p>要开始使用这个循环，我们需要设置任务的第一个单元，然后编写performUnitOfWork方法，这个方法不仅执行当前的任务，还会返回下一个单元的任务。</p>
<h1 id="第4步-fiber树">第4步 fiber树</h1>
<p>我们需要一种形如纤维树的数据结构来组织单元任务。每个React element，都会有一个对应的fiber，它们是一一对应的关系。</p>
<p>举个例子：
假设我们要渲染一个像这样的element树结构到DOM中：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Didact</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">a</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="err">/h1&gt;</span>
    <span class="o">&lt;</span><span class="nx">h2</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;,</span>
  <span class="nx">container</span>
<span class="p">)</span>
</code></pre></div><p><figure>
		<a href="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber1.png" data-size="274x318">
			<img srcset="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber1_hu7839c0de918d55ea891144c58fa5e709_3678_480x0_resize_box_2.png 480w, /ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber1_hu7839c0de918d55ea891144c58fa5e709_3678_1024x0_resize_box_2.png 1024w"
				src="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber1.png" width="274" height="318" loading="lazy"
				alt="fiber1.png">
		</a>
		
		<figcaption>fiber1.png</figcaption>
		
	</figure>
在render函数中我们会创建根fiber，然后将其设为nextUnitOfWork。其余的工作会在performUnitOfWork中进行，在该函数中我们会对每个fiber做以下三件事：</p>
<ol>
<li>add the element to the DOM 将element添加到DOM</li>
<li>create the fibers for the element’s children 为这个fiber的children创建它们自己的fiber</li>
<li>select the next unit of work 选择下一个单元任务</li>
</ol>
<p>这样类似纤维的数据结构的一个好处就是由于每个fiber都和自己的第一个子节点、相邻节点和父节点有一个连接，可以很容易确认下一个单元任务，即下一个要进行渲染的element。</p>
<ul>
<li>
<p>当我们完成了对一个fiber的任务的执行，如果这个fiber有子节点，那么这个子节点就会成为下一个单元任务。对于本例，当我们完成div这个fiber的工作，下一个单元任务将会是h1这个fiber。</p>
</li>
<li>
<p>如果当前的fiber没有子节点，我们会让它的相邻节点成为下个单元任务。例如，p这个fiber没有子节点，所以我们会在完成渲染它之后移动到a这个fiber。
<figure>
		<a href="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber3.png" data-size="274x318">
			<img srcset="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber3_huc1596146e0ca06b53eeb167d1b09910d_3705_480x0_resize_box_2.png 480w, /ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber3_huc1596146e0ca06b53eeb167d1b09910d_3705_1024x0_resize_box_2.png 1024w"
				src="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber3.png" width="274" height="318" loading="lazy"
				alt="fiber3.png">
		</a>
		
		<figcaption>fiber3.png</figcaption>
		
	</figure></p>
</li>
<li>
<p>而如果这个fiber没有子节点也没有相邻节点，我们会去找它的“叔叔”：父节点的相邻节点，例如本例中的h2。
<figure>
		<a href="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber4.png" data-size="274x318">
			<img srcset="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber4_hu4bf1c65f00b4e8a037288ff97bc35961_3781_480x0_resize_box_2.png 480w, /ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber4_hu4bf1c65f00b4e8a037288ff97bc35961_3781_1024x0_resize_box_2.png 1024w"
				src="/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/fiber4.png" width="274" height="318" loading="lazy"
				alt="fiber4.png">
		</a>
		
		<figcaption>fiber4.png</figcaption>
		
	</figure>
另外，如果父节点没有相邻节点，我们继续向上沿着父节点寻找，直到找到了有相邻节点的父节点，或者是到达根节点。如果我们到达了根节点，则说明我们已经完成了对这次render的所有任务。</p>
</li>
</ul>
<p>现在让我们用代码进行实现吧！</p>
<p>首先将原先render函数里的创建DOM的代码抽离出来：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建DOM
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;TEXT_ELEMENT&#39;</span> <span class="o">?</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">isProperty</span> <span class="o">=</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;children&#39;</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isProperty</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="c1">// 对子节点递归调用
</span><span class="c1"></span>    <span class="nx">element</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">child</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">render</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">dom</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="c1">// 添加到容器中
</span><span class="c1"></span>    <span class="nx">container</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">dom</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>将创建DOM的部分抽离出来形成一个新的方法createDOM，入参为fiber，即element。稍后我们会用到这个方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createDom</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;TEXT_ELEMENT&#39;</span> <span class="o">?</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">isProperty</span> <span class="o">=</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;children&#39;</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isProperty</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="p">});</span>
    <span class="k">return</span> <span class="nx">dom</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>然后，在render方法中，我们把fiber树的根节点作为nextUnitOfWork:</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">render</span> <span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 最初最初的节点为container，一个已有的DOM节点，放在nextUnitOfWork，即fiber的dom属性中
</span><span class="c1"></span>    <span class="c1">// nextUnitOfWork对象还有type属性，最初节点没有自身属性，只有children，包含一个我们创建好的element
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">dom</span><span class="o">:</span> <span class="nx">container</span><span class="p">,</span>
        <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">children</span><span class="o">:</span> <span class="p">[</span><span class="nx">element</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="kc">null</span>
</code></pre></div><p>然后，当浏览器ready后，它会调用我们上面所写的workLoop方法，我们就会开始从root进行渲染工作。
现在我们来实现performUnitOfWork方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 首先，我们创建一个新的DOM node，并将其添加到DOM中
</span><span class="c1"></span>    <span class="c1">// 我们用fiber.dom属性去追踪DOM节点信息
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span> <span class="o">=</span> <span class="nx">createDom</span><span class="p">(</span><span class="nx">fiber</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">dom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 2. 然后我们为每一个子节点创建一个新的fiber
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">prevSibling</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="kr">const</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">type</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span>
            <span class="nx">props</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">dom</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nx">parent</span><span class="o">:</span> <span class="nx">fiber</span>
        <span class="p">}</span>
        <span class="c1">// 建立fiber连接，根据索引是否为0设置为当前fiber的child或是上一个子节点的相邻节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">prevSibling</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">prevSibling</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 最后我们搜索并确立下一个单元任务。我们先试试子节点child，没有child的话就相邻节点=》父节点的相邻节点这样循环搜索。
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>以上就是performUnitOfWork方法的实现。</p>
<h1 id="第5步render和commit阶段">第5步：Render和Commit阶段</h1>
<p>现在我们还面临一个问题。每次我们对一个element进行操作时，都会将一个新的node节点那添加到DOM中，但是记住，浏览器可以在我们完成渲染整个树结构之前中断渲染工作去执行更高优先级的任务，在那种情况下，用户会看见一个不完整的UI。我们不希望那种情况发生。所以我们需要将修改DOM的代码片段抽离出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="c1">// 修改DOM，需要提出去
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">dom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>反之，我们需要持续跟踪fiber树的根。我们称它为work in progress root或wipRoot。在render方法中重新命名：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">render</span> <span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">wipRoot</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">dom</span><span class="o">:</span> <span class="nx">container</span><span class="p">,</span>
        <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">children</span><span class="o">:</span> <span class="p">[</span><span class="nx">element</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">wipRoot</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div><p>然后，当我们完成了所有的渲染工作（不存在下一个单元任务时）我们将整个fiber树提交到DOM中（每个fiber都已经带有了它对应要渲染到document上的附带属性的DOM节点）。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">commitRoot</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// TODO add nodes to dom
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">wipRoot</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">dom</span><span class="o">:</span> <span class="nx">container</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">children</span><span class="o">:</span> <span class="p">[</span><span class="nx">element</span><span class="p">],</span>
    <span class="p">},</span>
  <span class="p">}</span>
  <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">wipRoot</span>
<span class="p">}</span>
<span class="err">​</span>
<span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="kc">null</span>
<span class="kd">let</span> <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span>
<span class="err">​</span>
<span class="kd">function</span> <span class="nx">workLoop</span><span class="p">(</span><span class="nx">deadline</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">shouldYield</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">nextUnitOfWork</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">shouldYield</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">performUnitOfWork</span><span class="p">(</span>
      <span class="nx">nextUnitOfWork</span>
    <span class="p">)</span>
    <span class="nx">shouldYield</span> <span class="o">=</span> <span class="nx">deadline</span><span class="p">.</span><span class="nx">timeRemaining</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="err">​</span>  <span class="c1">// 没有下一个单元任务，说明fiber树构建完成，整体提交到DOM中
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nextUnitOfWork</span> <span class="o">&amp;&amp;</span> <span class="nx">wipRoot</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">commitRoot</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nx">requestIdleCallback</span><span class="p">(</span><span class="nx">workLoop</span><span class="p">)</span>
<span class="p">}</span>
<span class="err">​</span>
<span class="nx">requestIdleCallback</span><span class="p">(</span><span class="nx">workLoop</span><span class="p">)</span>
</code></pre></div><p>我们在commitRoot方法中实现提交功能。在commitWork里递归添加所有node到DOM树中。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">commitRoot</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 这里child就是实际要添加到已有DOM容器节点的根element
</span><span class="c1"></span>    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">wipRoot</span><span class="p">.</span><span class="nx">child</span><span class="p">);</span>
    <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">fiberParentDom</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">dom</span><span class="p">;</span>
    <span class="nx">fiberParentDom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">);</span>
    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h1 id="第6步reconciliation-调和-diff算法">第6步：Reconciliation 调和 （DIFF算法）</h1>
<p>目前为止我们只是完成了添加节点到DOM的实现，那么更新和删除节点呢？
这就是我们现在要做的，将我们在render方法中接收到的elements和上一个我们提交到DOM的fiber树进行对比。</p>
<p>所以我们需要将上一个完成渲染的fiber树保存到一个引用当中，我们叫它currentRoot。
同时，对每一个fiber添加一个alternate属性。这个属性是对旧fiber的链接，即我们在上一个从commit阶段提交到DOM的fiber。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">currentRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">wipRoot</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">dom</span><span class="o">:</span> <span class="nx">container</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">children</span><span class="o">:</span> <span class="p">[</span><span class="nx">element</span><span class="p">],</span>
    <span class="p">},</span>
    <span class="c1">// 添加alternate属性存储上一次渲染的对应的fiber
</span><span class="c1"></span>    <span class="nx">alternate</span><span class="o">:</span> <span class="nx">currentRoot</span>
  <span class="p">}</span>
  <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">wipRoot</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">commitRoot</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 这里child就是实际要添加到已有DOM容器节点的根element
</span><span class="c1"></span>    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">wipRoot</span><span class="p">.</span><span class="nx">child</span><span class="p">);</span>
    <span class="nx">currentRoot</span> <span class="o">=</span> <span class="nx">wipRoot</span><span class="p">;</span>
    <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">fiberParentDom</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">dom</span><span class="p">;</span>
    <span class="nx">fiberParentDom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">);</span>
    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>现在让我们把performUnitOfWork中创建新fiber的代码抽离出来：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span> <span class="o">=</span> <span class="nx">createDom</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span>
  <span class="p">}</span>
<span class="err">​</span>
  <span class="kr">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">prevSibling</span> <span class="o">=</span> <span class="kc">null</span>
<span class="err">​</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="err">​</span>
    <span class="kr">const</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span>
      <span class="nx">props</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
      <span class="nx">parent</span><span class="o">:</span> <span class="nx">fiber</span><span class="p">,</span>
      <span class="nx">dom</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">prevSibling</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="p">}</span>
    <span class="nx">prevSibling</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="nx">index</span><span class="o">++</span>
  <span class="p">}</span>
<span class="err">​</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">fiber</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span>
    <span class="p">}</span>
    <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">parent</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span> <span class="o">=</span> <span class="nx">createDom</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span>
  <span class="c1">// 当前的fiber和它的子节点们，调用构建fiber树结构函数reconcileChildren
</span><span class="c1"></span>  <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">elements</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">fiber</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span>
    <span class="p">}</span>
    <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">parent</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">wipFiber</span><span class="p">,</span> <span class="nx">elements</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">prevSibling</span> <span class="o">=</span> <span class="kc">null</span>
<span class="err">​</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="err">​</span>
    <span class="kr">const</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span>
      <span class="nx">props</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
      <span class="nx">parent</span><span class="o">:</span> <span class="nx">wipFiber</span><span class="p">,</span>
      <span class="nx">dom</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">prevSibling</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="p">}</span>
    <span class="nx">prevSibling</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="nx">index</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>继续修改reconcileChildren，这里我们会将旧的fibers和新的elements进行调和。
We iterate at the same time over the children of the old fiber (wipFiber.alternate) and the array of elements we want to reconcile.</p>
<p>如果我们忽略所有在一个数组和一个链表上同时遍历的样板代码（boilerplate）。我们会得到这里面最重要的两个变量：oldFiber和element。</p>
<p>我们需要对比这两个变量，即这次要渲染的fiber的子fiber和上次的子fiber，来确认我们时候要将什么变化应用到DOM上。</p>
<p>我们用type来比较它们:</p>
<ul>
<li>如果旧fiber和新element的type相同，我们可以让DOM node留在那里，只更新一些新的属性。</li>
<li>如果type不同，有一个新的element，这意味着我们需要创建一个新的node</li>
<li>如果type不同，有一个旧的fiber，我们需要移除掉旧的DOM node</li>
</ul>
<p>这里React也使用keys这个属性，这让调和效果更好。例如，它会发现子节点们在element数组中的排列顺序的改变。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">wipFiber</span><span class="p">,</span> <span class="nx">elements</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="c1">// 上次渲染到DOM的对应节点的子fiber
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">oldFiber</span> <span class="o">=</span> <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">alternate</span> <span class="o">&amp;&amp;</span> <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">.</span><span class="nx">child</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">prevSibling</span> <span class="o">=</span> <span class="kc">null</span>
<span class="err">​</span>
  <span class="c1">// 循环条件增加oldFiber不为空
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">oldFiber</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// element是现在要渲染到DOM上的节点的子fiber
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="err">​</span>    <span class="kd">let</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="c1">// 将旧fiber和现element进行比较
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">sameType</span> <span class="o">=</span> <span class="nx">element</span> <span class="o">&amp;&amp;</span> <span class="nx">oldFiber</span> <span class="o">&amp;&amp;</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">oldFiber</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
    <span class="c1">// 更新节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">sameType</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 创建一个新的fiber，维持旧fiber的dom，设置新element的props
</span><span class="c1"></span>        <span class="c1">// 同时添加一个新属性effectTag，这个属性会在稍后的commit阶段用到
</span><span class="c1"></span>        <span class="nx">newFiber</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">type</span><span class="o">:</span> <span class="nx">oldFiber</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span>
            <span class="nx">props</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">dom</span><span class="o">:</span> <span class="nx">oldFiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span>
            <span class="nx">parent</span><span class="o">:</span> <span class="nx">wipFiber</span><span class="p">,</span>
            <span class="nx">effectTag</span><span class="o">:</span> <span class="s1">&#39;UPDATE&#39;</span><span class="p">,</span>
            <span class="nx">alternate</span><span class="o">:</span> <span class="nx">oldFiber</span>
        <span class="p">}</span>
    <span class="c1">// 添加新节点
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">sameType</span> <span class="o">&amp;&amp;</span> <span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 对于element需要一个新的DOM节点的case，我们对新fiber添加一个值为PLACEMENT的tag
</span><span class="c1"></span>        <span class="nx">newFiber</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">type</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span>
            <span class="nx">props</span><span class="o">:</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">dom</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>  <span class="c1">// 后面会用fiber来调用createDom，这里只是将element转为fiber
</span><span class="c1"></span>            <span class="nx">parent</span><span class="o">:</span> <span class="nx">wipFiber</span><span class="p">,</span>
            <span class="nx">effectTag</span><span class="o">:</span> <span class="s1">&#39;PLACEMENT&#39;</span><span class="p">,</span>
            <span class="nx">alternate</span><span class="o">:</span> <span class="kc">null</span>
        <span class="p">}</span>
    <span class="c1">// 删除旧节点
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">sameType</span> <span class="o">&amp;&amp;</span> <span class="nx">oldFiber</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 对于要删除node的case，我们没有新的fiber，所以对旧fiber添加一个DELETION的tag。
</span><span class="c1"></span>        <span class="nx">oldFiber</span><span class="p">.</span><span class="nx">effectTag</span> <span class="o">=</span> <span class="s1">&#39;DELETION&#39;</span><span class="p">;</span>
        <span class="c1">// 但是，由于我们是从wipRoot提交fiber树到DOM中的，这个fiber树结构已经不再包含旧的fiber了
</span><span class="c1"></span>        <span class="c1">// 所以我们需要一个数组deletions来记录我们要移除的node节点
</span><span class="c1"></span>        <span class="nx">deletions</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">oldFiber</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">prevSibling</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="p">}</span>
    <span class="nx">prevSibling</span> <span class="o">=</span> <span class="nx">newFiber</span>
    <span class="nx">index</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">wipRoot</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">dom</span><span class="o">:</span> <span class="nx">container</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">children</span><span class="o">:</span> <span class="p">[</span><span class="nx">element</span><span class="p">],</span>
    <span class="p">},</span>
    <span class="nx">alternate</span><span class="o">:</span> <span class="nx">currentRoot</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="c1">// 每次开始渲染时，初始化要移除的node节点为空数组
</span><span class="c1"></span>  <span class="nx">deletions</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">wipRoot</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="kc">null</span>
<span class="kd">let</span> <span class="nx">currentRoot</span> <span class="o">=</span> <span class="kc">null</span>
<span class="kd">let</span> <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span>
<span class="kd">let</span> <span class="nx">deletions</span> <span class="o">=</span> <span class="kc">null</span>

<span class="c1">// 然后，当我们将变更提交到DOM时，我们也对那个数组中的fiber调用commitWork。
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">commitRoot</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">deletions</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">commitWork</span><span class="p">)</span>
  <span class="nx">commitWork</span><span class="p">(</span><span class="nx">wipRoot</span><span class="p">.</span><span class="nx">child</span><span class="p">)</span>
  <span class="nx">currentRoot</span> <span class="o">=</span> <span class="nx">wipRoot</span>
  <span class="nx">wipRoot</span> <span class="o">=</span> <span class="kc">null</span>
<span class="p">}</span>
<span class="err">​</span>
</code></pre></div><p>接下来要修改commitWork方法来处理上面增加的effectTag：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">domParent</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">dom</span><span class="p">;</span>
    <span class="c1">// 如果fiber有PLACEMENT这个effect tag我们就和之前一样，添加fiber的dom节点到它的parent的dom节点中去。
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">effectTag</span> <span class="o">===</span> <span class="s1">&#39;PLACEMENT&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">domParent</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span>
        <span class="c1">// 如果是UPDATE，那么就将新fiber的props更新到已有的dom节点中
</span><span class="c1"></span>        <span class="c1">// 并且替换掉之前已有的props的值
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">effectTag</span> <span class="o">===</span> <span class="s1">&#39;UPDATE&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">updateDom</span><span class="p">(</span>
            <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span>
            <span class="nx">fiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span>
        <span class="p">)</span>
      <span class="c1">// 如果是DELETION，我们就做相反操作，移除子节点
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">effectTag</span> <span class="o">===</span> <span class="s1">&#39;DELETION&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">domParent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">);</span>
    <span class="nx">commitWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>接下来要实现updateDom方法。我们将旧fiber和新fiber的props进行比较，移除那些不再有的props，并且设置那些新的props或者是变化了的值的props。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 是新值或者是全新的prop
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">isNew</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">prev</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">next</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="kr">const</span> <span class="nx">isGone</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="o">!</span><span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">next</span><span class="p">);</span>
<span class="c1">// 注意，还有一种特殊prop我们可能需要更新的是event listener。所以如果以on为开头的prop我们需要对它们进行特殊处理。
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">isEvent</span> <span class="o">=</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">isProperty</span> <span class="o">=</span> <span class="nx">key</span> <span class="p">=&gt;</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;children&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isEvent</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="kd">function</span> <span class="nx">updateDom</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果事件监听器变了，或者不再有，那么我们需要先移除掉旧的。
</span><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isEvent</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span>
            <span class="nx">key</span> <span class="p">=&gt;</span>
                <span class="o">!</span><span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">nextProps</span><span class="p">)</span> <span class="o">||</span>
                <span class="nx">isNew</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">)(</span><span class="nx">key</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">eventType</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="nx">dom</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="nx">eventType</span><span class="p">,</span> <span class="nx">prevProps</span><span class="p">[</span><span class="nx">name</span><span class="p">]);</span>
        <span class="p">})</span>
    <span class="c1">// 移除旧的property
</span><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isProperty</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isGone</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">))</span>
        <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
        <span class="p">})</span>
    <span class="c1">// 设置新的或值变了的property
</span><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isProperty</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isNew</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">))</span>
        <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextProps</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="p">})</span>
    <span class="c1">// 然后添加新fiber的事件监听器
</span><span class="c1"></span>    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isEvent</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isNew</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">))</span>
        <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">eventType</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="nx">dom</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">eventType</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">[</span><span class="nx">name</span><span class="p">]);</span>
        <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>至此，我们完成了调和工作啦！
尝试地址：https://codesandbox.io/s/didact-6-96533</p>
<h1 id="第7步函数组件">第7步：函数组件</h1>
<p>我们下一步要做的就是添加对函数式组件的支持。
首先让我们来修改一下例子。我们会用这个简单的返回一个h1元素的函数组件。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 普通写法，没有带自定义组件
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">a</span><span class="o">&gt;</span><span class="nx">bar</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
    <span class="o">&lt;</span><span class="nx">b</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="p">)</span>
<span class="c1">// 函数式组件写法
</span><span class="c1"></span><span class="cm">/** @jsx Didact.createElement */</span>
<span class="kd">function</span> <span class="nx">App</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hi</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/h1&gt;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">App</span> <span class="nx">name</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span> <span class="o">/&gt;</span>
<span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">)</span>
<span class="nx">Didact</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span>
</code></pre></div><p>我们将这段jsx代码转译成js，就会变成：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">App</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Didact</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
    <span class="s2">&#34;h1&#34;</span><span class="p">,</span>
    <span class="kc">null</span><span class="p">,</span>
    <span class="s2">&#34;Hi &#34;</span><span class="p">,</span>
    <span class="nx">props</span><span class="p">.</span><span class="nx">name</span>
  <span class="p">)</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">Didact</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">App</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;foo&#34;</span><span class="p">,</span>
<span class="p">})</span>
</code></pre></div><p>函数式组件在两个方面有所区别：</p>
<ul>
<li>源自函数组件的fiber没有DOM节点</li>
<li>子节点们是在运行函数时得来的，而不是直接从props中得来</li>
</ul>
<p>因此在performUnitOfWork方法中，我们重构创建dom和获取子节点的代码段，改为检查fiber的type是否是function，并根据判断结果去执行不同的update方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if (!fiber.dom) {
</span><span class="c1"></span>    <span class="c1">//     fiber.dom = createDom(fiber)
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>    <span class="c1">// const elements = fiber.props.children
</span><span class="c1"></span>    <span class="c1">// // 当前的fiber和它的子节点们，调用构建fiber树结构函数reconcileChildren
</span><span class="c1"></span>    <span class="c1">// reconcileChildren(fiber, elements)
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">isFunctionComponent</span> <span class="o">=</span>
        <span class="nx">fiber</span><span class="p">.</span><span class="nx">type</span> <span class="k">instanceof</span> <span class="nb">Function</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isFunctionComponent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">updateFunctionComponent</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">updateHostComponent</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 遍历fiber链表
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">fiber</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">sibling</span>
        <span class="p">}</span>
        <span class="nx">nextFiber</span> <span class="o">=</span> <span class="nx">nextFiber</span><span class="p">.</span><span class="nx">parent</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="err">​</span>
<span class="c1">// 在updateHostComponent中我们会和之前做一样的事情
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">updateHostComponent</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span> <span class="o">=</span> <span class="nx">createDom</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span>
    <span class="c1">// 当前的fiber和它的子节点们，调用构建fiber树结构函数reconcileChildren
</span><span class="c1"></span>    <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">elements</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在updateFunctionComponent函数中我们执行获取组件本身（函数）来获取其子节点。
对于我们的例子，在这里fiber.type是App这个方法，而当我们去执行它，它会返回h1 这个element。
然后，一旦我们获取到了子节点，reconciliation以一样的方式工作，我们不需要在那里修改任何东西。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">updateFunctionComponent</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="p">[</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">)]</span>
  <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">children</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在我们需要修改commitWork这个方法。有了不带DOM节点的fiber，所以我们需要修改两个地方。
首先，要找到父fiber的DOM节点我们需要沿着fiber树向上走，知道找到一个拥有DOM node的fiber。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// const domParent = fiber.parent.dom;
</span><span class="c1"></span> <span class="kd">let</span> <span class="nx">domParentFiber</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">parent</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">domParentFiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">domParentFiber</span> <span class="o">=</span> <span class="nx">domParentFiber</span><span class="p">.</span><span class="nx">parent</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">domParent</span> <span class="o">=</span> <span class="nx">domParentFiber</span><span class="p">.</span><span class="nx">dom</span>
</code></pre></div><p>另外，删除一个节点是也是要沿着fiber树向下寻找child，到找到了有DOM node的fiber。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">effectTag</span> <span class="o">===</span> <span class="s1">&#39;DELETION&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">commitDeletion</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">domParent</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">commitDeletion</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">domParent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">dom</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">domParent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">fiber</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">commitDeletion</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">child</span><span class="p">,</span> <span class="nx">domParent</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/** @jsx Didact.createElement */</span>
<span class="kd">function</span> <span class="nx">App</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hi</span> <span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/h1&gt;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">App</span> <span class="nx">name</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span> <span class="o">/&gt;</span>
<span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">)</span>
<span class="nx">Didact</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span>
</code></pre></div><h1 id="第8步-hooks">第8步 Hooks</h1>
<p>最后一步。既然我们有了函数组件，那么让我们也加下state。
让我们将例子更改为经典的counter组件。每次我们点击它，它都会将state加1。请注意我们在使用Didact.useState来获取和更新counter的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Didact</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">createElement</span><span class="p">,</span>
  <span class="nx">render</span><span class="p">,</span>
  <span class="nx">useState</span><span class="p">,</span>
<span class="p">}</span>

<span class="cm">/** @jsx Didact.createElement */</span>
<span class="kd">function</span> <span class="nx">Counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Here is where we call the Counter function from the example. And inside that function we call useState.
</span><span class="c1"></span>  <span class="kr">const</span> <span class="p">[</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Didact</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="p">=&gt;</span> <span class="nx">setState</span><span class="p">(</span><span class="nx">c</span> <span class="p">=&gt;</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;</span>
      <span class="nx">Count</span><span class="o">:</span> <span class="p">{</span><span class="nx">state</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="err">/h1&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">Counter</span> <span class="o">/&gt;</span>
<span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">)</span>
<span class="nx">Didact</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span>

<span class="kd">function</span> <span class="nx">useState</span><span class="p">(</span><span class="nx">initial</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>在调用函数组件之前，我们需要初始化一些全局变量，这样我们就能在useState方法中使用它们。
首先我们设置工作中的fiber。
我们同样添加一个hooks数组到fiber中，来支持在同一个组件中多次调用useState。并且我们保持跟踪现在的hook索引。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">wipFiber</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hookIndex</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">updateFunctionComponent</span><span class="p">(</span><span class="nx">fiber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在更新函数组件的方法中初始化hooks
</span><span class="c1"></span>    <span class="nx">wipFiber</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">;</span>
    <span class="nx">hookIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">hooks</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kr">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="p">[</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">props</span><span class="p">)];</span>
    <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">children</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>当函数组件调用useState方法时，我们去检查是否有一个旧的hook。我们用hook索引去到这个fiber的alternate中检查。</p>
<p>如果我们有一个旧的hook，我们将旧hook中的state复制到新的hook中；如果我们没有，那么就初始化这个state。</p>
<p>然后我们添加这个新的hook到fiber中，给hook索引加1，然后返回这个state。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">useState</span><span class="p">(</span><span class="nx">initial</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">oldHook</span> <span class="o">=</span> <span class="nx">wipFiber</span> <span class="o">&amp;&amp;</span> <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">.</span><span class="nx">hooks</span> <span class="o">&amp;&amp;</span> <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">.</span><span class="nx">hooks</span><span class="p">[</span><span class="nx">hookIndex</span><span class="p">];</span>
    <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">state</span><span class="o">:</span> <span class="nx">oldHook</span> <span class="o">?</span> <span class="nx">oldHook</span><span class="p">.</span><span class="nx">state</span> <span class="o">:</span> <span class="nx">initial</span>
    <span class="p">}</span>
    <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">hook</span><span class="p">);</span>
    <span class="nx">hookIndex</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">state</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>useState还应该返回一个更新state的函数，所以我们定义一个setState方法，这个方法接收一个action（对于Counter例子而言，这个action就是一个让state加1的函数）。
我们将那个action添加到hook的queue队列中。
然后我们做一些和在render函数中所做的类似的事情：设置一个新的工作中root，作为下一个单元任务，这样work loop就能开始一个新的render阶段。</p>
<p>注意我们还没有执行action。</p>
<p>我们在下一次render组件时执行。从旧的hook的queue中获取所有actions，然后将它们逐一运用到新的hook state中，因此当我们最终返回state时它是更新过的。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">useState</span><span class="p">(</span><span class="nx">initial</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">oldHook</span> <span class="o">=</span> <span class="nx">wipFiber</span> <span class="o">&amp;&amp;</span> <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">.</span><span class="nx">hooks</span> <span class="o">&amp;&amp;</span> <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">.</span><span class="nx">hooks</span><span class="p">[</span><span class="nx">hookIndex</span><span class="p">];</span>
    <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">state</span><span class="o">:</span> <span class="nx">oldHook</span> <span class="o">?</span> <span class="nx">oldHook</span><span class="p">.</span><span class="nx">state</span> <span class="o">:</span> <span class="nx">initial</span><span class="p">,</span>
        <span class="nx">queue</span><span class="o">:</span> <span class="p">[],</span> <span class="c1">// queue存放setState的入参，表示一个修改state的函数
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// 执行actions
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">actions</span> <span class="o">=</span> <span class="nx">oldHook</span> <span class="o">?</span> <span class="nx">oldHook</span><span class="p">.</span><span class="nx">queue</span> <span class="o">:</span> <span class="p">[];</span>
    <span class="nx">actions</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">action</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">hook</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">action</span><span class="p">(</span><span class="nx">hook</span><span class="p">.</span><span class="nx">state</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="kr">const</span> <span class="nx">setState</span> <span class="o">=</span> <span class="nx">action</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="c1">// 浏览器空闲时进行重新performUnitOfWork
</span><span class="c1"></span>        <span class="nx">wipRoot</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">dom</span><span class="o">:</span> <span class="nx">currentRoot</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span>
            <span class="nx">props</span><span class="o">:</span> <span class="nx">currentRoot</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span>
            <span class="nx">alternate</span><span class="o">:</span> <span class="nx">currentRoot</span>
        <span class="p">}</span>
        <span class="nx">nextUnitOfWork</span> <span class="o">=</span> <span class="nx">wipRoot</span><span class="p">;</span>
        <span class="nx">deletions</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>
    <span class="nx">wipFiber</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">hook</span><span class="p">);</span>
    <span class="nx">hookIndex</span><span class="o">++</span><span class="p">;</span> <span class="c1">// hooks一定要有顺序
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">setState</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>以上就是我们自行实现的版本的React啦！
在线版本：https://codesandbox.io/s/didact-8-21ost</p>
<h1 id="后记">后记</h1>
<p>Besides helping you understand how React works, one of the goals of this post is to make it easier for you to dive deeper in the React codebase. That’s why we used the same variable and function names almost everywhere.</p>
<p>For example, if you add a breakpoint in one of your function components in a real React app, the call stack should show you:</p>
<ul>
<li>workLoop</li>
<li>performUnitOfWork</li>
<li>updateFunctionComponent</li>
</ul>
<p>We didn’t include a lot of React features and optimizations. For example, these are a few things that React does differently:</p>
<ul>
<li>In Didact, we are walking the whole tree during the render phase. React instead follows some hints and heuristics to skip entire sub-trees where nothing changed.</li>
<li>We are also walking the whole tree in the commit phase. React keeps a linked list with just the fibers that have effects and only visit those fibers.</li>
<li>Every time we build a new work in progress tree, we create new objects for each fiber. React recycles the fibers from the previous trees.</li>
<li>When Didact receives a new update during the render phase, it throws away the work in progress tree and starts again from the root. React tags each update with an expiration timestamp and uses it to decide which update has a higher priority.</li>
<li>And many more…</li>
</ul>
<p>There are also a few features that you can add easily:</p>
<ul>
<li>use an object for the style prop</li>
<li>flatten children arrays</li>
<li>useEffect hook</li>
<li>reconciliation by key</li>
</ul>
<p>If you add any of these or other features to Didact send a pull request to the GitHub repo, so others can see it.
<a href="https://github.com/pomber/didact">https://github.com/pomber/didact</a></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/ObzerverZQ.github.io/tags/react/">React</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
</aside>


    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>


    

    <footer class="site-footer">
    <section class="copyright">&copy; 2021 Observer的小家</section>
    <section class="powerby">Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="1.1.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true" style="display:none">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
            </main>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ObzerverZQ.github.io/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<link rel="stylesheet" href="/ObzerverZQ.github.io/css/highlight/light.min.css" media="(prefers-color-scheme: light)">
<link rel="stylesheet" href="/ObzerverZQ.github.io/css/highlight/dark.min.css" media="(prefers-color-scheme: dark)">

    </body>
</html>
