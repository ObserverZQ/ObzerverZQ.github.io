[{"content":"冒泡排序 基本思路：从左至右遍历数组，取一个指针指向第一个元素，与下一个元素比较，若该元素更大则前后交换位置，然后指针取下一位，与后一位进行比较，继续这样的循环，这样一轮下来会使得最大值放在数组的末尾，类似吐泡泡一样。之后重新开始循环上述过程，将第二大的元素放在倒数第二位。\nfunction bubbleSort(array) { let isSorted = true; let len = array.length; for (let i = 0; i \u0026lt; len; i ++) { for (let j = 0; （j \u0026lt; len - i - 1） \u0026amp;\u0026amp; array[j] \u0026gt; array[j + 1]; j++) { [array[j], array[j + 1]] = [array[j + 1], array[j]]; } if (isSorted) { break; } } return array; } 时间复杂度上，最好情况是O(n)，即数组已经完全排好序，后一个元素永远比前一个元素大，不需要冒泡，只需要遍历一次，平均和最坏情况是O(n2)。\n选择排序 基本思路：从左至右遍历数组，比较一圈后得到最小值的索引，与索引0的元素交换位置；接着从第2位开始循环上述操作，将第二小的元素放在索引为1的位置，以此类推。每次遍历的时间为O(n)，这样的时间复杂度为O(n2)。\nfunction selectionSort(array) { for (let i = 0, len = array.length; i \u0026lt; len - 1; i++) { let min = i; for (let j = i + 1; j \u0026lt; len; j++) { if (array[j] \u0026lt; array[min]) { min = j; } } [array[i], array[min]] = [array[min], array[i]] } return array; } 时间复杂度上，最好、平均、最坏情况都是O(n2)。\n插入排序 基本思路：从左至右遍历，新元素通过与左边已经排好序的数组逐一比对，插入至左边的数组中，将比遍历到的元素大的元素统统右移一位。\nfunction insertionSort(array) { for (let i = 0, len = array.length; i++) { let j = i; const temp = array[j]; while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; array[j - 1]) { array[j] = array[j - 1]; j--; } array[j] = temp; } return array; } 时间复杂度上，最好情况为O(n)，即数组已经完全排好序，平均和最坏情况为O(n2)。\n下面进入到时间复杂度降低了的快速排序和归并排序。\n快速排序quicksort 法一 基本思路：选择一个基准值（随意选择），遍历数组（除基准值以外），将比基准值小的push到一个数组，放到基准值左侧，将比基准值大的push到另一个数组，放到基准值右侧，并对新的两个数组继续递归调用该函数，即为该函数的返回结果。基线条件为入参数组的长度为1，结束递归，直接返回该数组。递归过程逐个栈完成调用返回结果。\nfunction quickSort(array) { if (array.length \u0026lt; 2) { return array; } let pivot = array[0]; let low = []; let high = []; for (let i = 1; i \u0026lt; array.length; i++) { if (array[i] \u0026lt;= pivot) { low.push(array[i]); } else { high.push(array[i]); } } return quickSort(low).concat(pivot, quickSort(high)); } 每层实际还是遍历了O(n)个元素，而调用栈共有O(logn)层（相当于二分，所以是2的对数），所以平均情况的时间复杂度为O(n) * O(log n) = O(nlogn)。 最糟情况下，例如一个已经排好序的数组，基准值从第一个元素取，则右边分出来的数组拆分为原长度减1的数组，所以调用栈为n层，此时时间复杂度为O(n2)。但是一般都不会遇到最糟情况。\n法二 实现分析：\n将当前数组分区 分区时先选择一个基准值，再创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直至找到一个比基准值大的元素，再移动右指针直至找到一个比基准值小的元素，然后交换它们，重复这个过程，直到左指针的位置超过了右指针。如此分区、交换使得比基准值小的元素都在基准值之前，比基准值大的元素都在基准值之后，这就是分区（partition）操作。 对于上一次分区后的两个区域重复进行分区、交换操作，直至分区到最小。\nfunction quickSort(unsorted) { function partition(array, left, right) { const pivot = array[ Math.floor((left + right) / 2) ]; while (left \u0026lt;= right) { while (array[left] \u0026lt; pivot) { left++; } while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { [array[left], array[right]] = [array[right], array[left]]; left++; right--; } } return left; } function quick(array, left, right) { if (array.length \u0026lt;= 1) { return array; } const index = partition(array, left, right); if (left \u0026lt; index - 1) { quick(array, left, index - 1); } if (right \u0026gt; index) { quick(array, index, right); } return array; } return quick(unsorted, 0, unsorted.length - 1); } 时间复杂度上，最好、平均复杂度是O(nlogn)，最坏情况是O(n2)\n合并排序mergesort 基本思路：取位于数组中间的值，将左侧右侧各生成一个新数组（split），然后调用merge函数，各用一个索引进行逐个遍历比较，将较小的推送至结果数组中，直至其中一个数组遍历结束，对有剩余元素的那个数组在尾部加至结果数组。对新数组递归拆分操作，并调用该merge函数，直至左右数组的长度为0。\n将数组从中间切分为两个数组 切分到最小之后，开始归并操作，即合并两个已排序的数组 递归合并的过程，由于是从小到大合并，所以待合并的两个数组总是已排序的，一直做同样的归并操作就可以\nfunction mergeSort(array) { function merge(arrL, arrR) { let indexL = indexR = 0; const lenL = arrL.length; const lenR = arrR.length; const result = []; while (indexL \u0026lt; lenL \u0026amp;\u0026amp; indexR \u0026lt; lenR) { if (arrL[indexL] \u0026lt;= arrR[indexR]) { result.push(arrL[indexL++]); } else { result.push(arrR[indexR++]); } } while (indexL \u0026lt; lenL) { result.push(arrL[indexL++]) } while (indexR \u0026lt; lenR) { result.push(arrR[indexR++]) } return result; } function split(array) { const len = array.length / 2 let mid = Math.floor(len); const arrL = array.slice(0, mid); const arrR = array.slice(mid, len); return merge(split(arrL), split(arrR)); } return split(array); } 时间复杂度上，最好、平均和最坏情况都是 O(nlog(n))。\n对比归并排序与快速排序  都用了分治的思想。相比选择排序和冒泡排序，归并排序与快速排序使用了切分而不是直接遍历，这有效减少了交换次数。 归并排序是先切分、后排序，过程可以描述为：切分、切分、切分……排序、排序、排序…… 快速排序是分区、排序交替进行，过程可以描述为：分区、排序、分区、排序…… 上两条所说的“排序”，在归并排序与快速排序中并非同样的操作，归并排序中的操作是将两个数组合并为一（归并操作），而快速排序中的操作是交换。 归并排序，由小及大，小的排好序的数组递归合并为大的排好序的数组，逐渐递归覆盖到整个原始数组；快速排序，由大及小，先将大的整个数组根据基准值进行大小分区，再逐渐切小，对小的分区进行大小分区。  参考资料： 归并排序与快速排序的简明实现及对比\n","date":"2021-02-26T19:11:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/array_sorting_algorithm_huec1666719498bd6a587a8e0b2a8ad6f2_69768_120x120_fill_box_smart1_2.png","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"JavaScript实现常见排序算法"},{"content":"临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。\n为帮助 Node.js 开发人员更好的面试，我列出了 15 个常见的 Node.js 和网络开发相关的面试问题。\n在本文中，我们将重点讨论 Node.js 相关问题。但是，请记住 JavaScript 问题在 Node.js 面试中也经常问到，所以准备一些对你来说没什么坏处。不久前我们写了一篇关于常见 JavaScript 面试问题的帖子，涵盖了所有这些基础。\nhttps://livecodestream.dev/post/20-common-javascript-interview-questions/\n现在，让我们深入了解面试中可能会问到的 Node.js 问题。\n Node.js 与 JavaScript 有什么不同?    Image \n什么时候用 Node.js？ Node.js 是异步的、事件驱动的、非阻塞的和单线程的，使得它成为开发下面应用程序的完美候选：    实时应用程序，如聊天和提供实时更新的应用程序\n  将视频或其他多媒体内容流式传输给大量观众的流式应用程序\n  其他 I/O 密集型应用程序，如协作平台\n  遵循微服务架构的网络后端\n  然而，Node.js 的特性使得它对于其他类型的应用程序来说不是一个理想的选择。执行 CPU 密集型任务的应用程序（如复杂的数学计算）在使用 CPU 时表现不佳，因为 Node.js 是单线程的。\nEventEmitter 做了什么？ Node.js 中任何对象发出的事件都是 EventEmitter 类的实例，就像 http 模块。  所有 EventEmitter 类都可以使用 eventEmitter.on() 函数将事件侦听器附加到事件。然后一旦捕捉到这样的事件，就会同步地逐个调用它的侦听器。\nconst events = require(\u0026#34;events\u0026#34;); const eventEmitter = new events.EventEmitter(); const eventListener = function(){ console.log(\u0026#34;event triggered\u0026#34;); } eventEmitter.on(\u0026#34;emitted\u0026#34;, eventListener); eventEmitter.emit(\u0026#34;emitted\u0026#34;); 事件循环是什么?  单线程的 Node.js 必须是非阻塞的，以防止线程阻塞在需要很长时间才能完成的任务上，事件循环负责实现这种非阻塞行为，它使用应用程序线程调度挂起的任务。\nNode.js 在任务完成时通过回调来处理异步函数返回的响应。与创建任务的事件类似，任务完成后也会发出一个事件。Node.js 将需要处理的事件添加到事件队列。\n事件循环对事件队列中的事件进行迭代，并安排何时执行其关联的回调函数。\n流是什么?  Stream 流是从源读取或写入数据并将其传输到连续流目标的管道。有四种类型：\n  可读\n  可写的\n  可读写\n  先写入，再读出来\n  每个流也是一个 EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件。\nconst fs = require(\u0026#34;fs\u0026#34;); const readableStream = fs.createReadStream(\u0026#34;test.txt\u0026#34;); let content = \u0026#34;\u0026#34;; readableStream.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { content += chunk; }); readableStream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(content); }); readFile 和 createReadStream 函数有什么区别？  readFile 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。\ncreateReadStream 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。\n与 readFile 相比，createReadStream 使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会先向用户发送小块内容。\nconst fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#34;test.txt\u0026#34;, (err, content) =\u0026gt; { console.log(content); }); 如何处理 Node.js 中未捕获的异常？  我们可以在进程级别捕获应用程序中未捕获的异常。为此将侦听器附加到 process 全局对象：\nprocess.on(\u0026#34;uncaughtException\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;exception caught: \u0026#34;, err); }); Node.js 能否充分利用多核处理器？ （默认的）Node.js 应用程序总是单线程的，即使在多核处理器上运行，应用程序也能只使用一个处理器。  但是 Node.js 的核心模块之一 Cluster 支持 Node.js 应用程序开启多核，允许我们创建多个工作进程，这些进程可以在多个内核上并行运行，并共享一个端口来侦听事件。\n每个进程使用 IPC 与主线程通信，并根据需要将服务器句柄传递给其他进程。主进程可以侦听端口本身并以循环方式将每个新连接传递给子进程，也可以将端口分配给子进程以便子进程侦听请求。\n反应堆设计模式是什么？ 反应堆设计模式是，Node.js 将回调函数（处理程序）附加到每个 I/O 操作，然后创建请求时将处理程序提交给解复用器。  解复用器收集应用程序中发出的每个 I/O 请求，并将它们作为队列中的事件进行排队。这个队列就是我们所说的事件队列。将事件排队后，解复用器返回应用程序线程的控制。\n同时，事件循环遍历事件队列中的每个事件，并调用附加的回调来处理事件响应。\n这就是 Node.js 中所使用的反应堆模式。\n单线程与多线程网络后端相比有哪些好处？  尽管 Node.js 是单线程的，但是大多数用于后端开发的编程语言都提供多线程来处理应用程序操作。而为什么单线程有利于后端开发？\n开发人员更容易实现应用程序。我们的应用程序在生产过程中不会突然遇到意外的竞争条件。\n单线程应用程序易于扩展。\n它们可以毫不延迟地在一个时刻收到的大量用户请求提供服务。相比之下，当流量较大时，多线程后端必须等待线程池中的线程释放，才能为用户请求提供服务。利用 Node.js 的非阻塞特性，用户请求不会在单个线程上挂起太长时间（只有在操作不是 CPU 密集型时）。\nREPL 是什么？  REPL 代表 Read Eval Print Loop，是一个虚拟环境，可以在其中轻松地运行编程语言。Node.js 带有一个内置的 REPL 来运行 JavaScript 代码，类似于我们在浏览器中用来运行 JavaScript 代码的控制台。\n要启动 Node.js REPL，只需在命令行上运行 node，然后写一行 JavaScript 代码，就可以在下一行看到它的输出。\nprocess.nextTick 和 setImmediate 有什么区别？ 传递给 setImmediate 函数的回调将在事件队列上的下一次迭代中执行。  另一方面，回调传递给 process.nextTick 在下一次迭代之前以及程序中当前运行的操作完成之后执行。在应用程序启动时，开始遍历事件队列之前调用它的回调。\n因此，回调 process.nextTick 总是在 setImmediate 之前调用。\n下面代码段：\nsetImmediate(() =\u0026gt; { console.log(\u0026#34;first\u0026#34;); }) process.nextTick(() =\u0026gt; { console.log(\u0026#34;second\u0026#34;); }) console.log(\u0026#34;third\u0026#34;); 将按顺序输出： third second first 13. stub 是什么? 测试应用程序时使用 stub，模拟给定组件或模块的行为，你可以将精力集中在要测试的代码部分。通过使用 stub 代替与测试无关的组件，不必担心外部组件会影响结果。\n例如，如果正在测试的组件在预期测试的部分之前有一个文件读取操作，则可以使用 stub 来模拟该行为并返回模拟内容，而不用实际读取文件。\n在 Node.js 中，我们使用像 Sinon 这样的库来实现（译者注，Sinon 在测试中替换某部分代码，减少测试项编写的复杂度 https://sinonjs.org）。\n为什么在 express 中分离“应用程序”和“服务器”是一种好的做法？ 通过在 Express 中分离应用程序和服务器，可以将 API 实现与网络相关配置分开。在不执行网络调用的情况下执行 API 测试，保证了更快的测试执行和更好的代码覆盖度量。  要实现这种分离，应该在单独的文件中声明 API 和 server，对应 app.js 和 server.js：\n// app.js const express = require(\u0026#34;express\u0026#34;); const app = express(); app.use(\u0026#34;/\u0026#34;, index); app.use(\u0026#34;/contact\u0026#34;, contact); app.use(\u0026#34;/user\u0026#34;, user); module.exports = app; // server.js const http = require(\u0026#34;http\u0026#34;); const app = require(\u0026#34;/app\u0026#34;); app.set(\u0026#39;port\u0026#39;, process.env.PORT); const http = http.createServer(app); 什么是 yarn 和 npm？为什么要用 yarn 代替 npm 呢？ npm 是与 Node.js 自带的默认包管理器，它有一个大型的公共库和私有库，存储在 npm registry 的数据库中（译者注，官方默认中心库 http://registry.npmjs.org/，国内淘宝镜像 http://registry.npm.taobao.org/），用户可以通过 npm 命令行访问该数据库。在 npm 的帮助下，用户可以轻松管理项目中的依赖项。  yarn 也是一个包管理器，为了解决 npm 的一些缺点。yarn 依赖 npm 注册中心为用户提供对包访问。yarn 底层结构基于 npm，如果从 npm 迁移到 yarn，项目结构和工作流不需要大改。\n就像之前提到的，在某些情况下，yarn 提供了比 npm 更好的功能。与 npm 不同的是，它会缓存下载的每个包，不必重新下载。\n通过校验和验证包的完整性来提供更好的安全性，保证在某个系统上运行的包在任何其他系统中的工作方式完全相同，这就是为什么选择 yarn 而不是 npm 来进行包管理。\n结论 在本文中，讨论了 15 个最常见的 Node.js 面试问题，帮助你为下一次面试做准备。知道你可能被问到的问题和答案，面试就不再紧张了。\n祝你好运，面试成功！临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。\n参考资料：\n15 个常见的 Node.js 面试问题及答案\n","date":"2021-02-22T19:23:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/node.js-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%9815%E6%9D%A1/640_hu992ded1d4f7b7b2034fd8a8bad8be327_108856_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/node.js-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%9815%E6%9D%A1/","title":"Node.js 常见问题15条"},{"content":"WebSocket 工作在七层（或者四层）中的哪一层？和 HTTP 是什么关系？ 是基于 UDP 的还是 TCP 的？ TCP 为什么是三次握手？为什么是四次挥手？ CDN 的工作原理是什么？ 运营商劫持是什么？如何防范？ HTTPS 一定是安全的么？如果不是，那么在什么情况下是不安全的？ 如何劫持 HTTPS 请求。 比如你需要抓 HTTPS 的包，怎么做？ 支付宝和微信的离线支付是怎么做的？ Token 和 Cookie 有什么区别和联系呢？其分别是为了解决什么样的事情？ WebSocket 需要 cookie 么？为什么？ WebSocket 是怎么实现点对点通信和广播通信的？ 如果访问你的 APP 很慢，你自己无法重现。 初步定位到网络问题， 那么你怎么能具体定位到问题呢？ traceroute, Ping 的原理是什么？ 192.168.0.1 和 192.168.1.1 如何通信？ DNS 是如何泄漏个人隐私的？怎么防范？ 从网络协议模型（七层 or 四层）的角度分析一下，浏览器访问 192.168.3.4:8088 的具体过程。\n","date":"2021-01-12T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BA%8C%E7%BD%91%E7%BB%9C/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BA%8C%E7%BD%91%E7%BB%9C/","title":"前端知识汇总（二）：网络"},{"content":"事件模型 不论是浏览器还是Node.js，都有自己的事件模型，它们都是事件驱动的，即依靠事件来维持运行。 现在比较推荐的绑定事件的方法是addEventListener：\ntarget.addEventListener(type, listener[, options]); target.addEventListener(type, listener[, useCapture]); target.addEventListener(type, listener[, useCapture, wantsUntrusted ]); // Gecko/Mozilla only 旧版本的第三个参数是bool，表示是否是捕获阶段，默认是false，即默认为冒泡阶段。新版本是一个对象，其中有capture（和上面功能一样），passive和once。once用来执行是否只执行一次，passive如果被指定为true, 表示永远不会执行preventDefault(),这在实现丝滑柔顺的滚动的效果中很重要。Improving scrolling performance with passive listeners\n框架中的事件 框架中的事件 实际上，我们现在大多数情况都是用框架来写代码，因此上面的情况其实在现实中是非常少见的，我们更多看到的是框架封装好的事件，比如React的合成事件，感兴趣的可以看下这几篇文章。\n React SyntheticEvent Vue和React的优点分别是什么？两者的最核心差异对比是什么？  虽然我们很少时候会接触到原生的事件，但是了解一下事件对象，事件机制，事件代理等还是很有必要的，因为框架的事件系统至少在这方面还是一致的，这些内容我们接下来就会讲到。\n事件对象 function handleClick(e: Event) { // ... } 这个e就是事件对象，它包含一些重要属性和方法：\n 属性   target x, y等位置信息 timeStamp eventPhase   方法   preventDefault 用于阻止浏览器的默认行为，比如a标签会默认进行跳转，form会默认校验并发送请求到action指定的地址等 stopPropagation 用于阻止事件的继续冒泡行为，后面讲事件传播的时候会提到。  事件循环 事件指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。循环指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。 一段JS代码，需要被编译成机器可理解并执行的指令，这就依赖JS引擎。而V8引擎中，有两个核心组成，即执行栈和堆。执行栈中存放正在执行的代码段，堆中存放变量的值。以一段简单代码为例：\nfunction c() {} function b() { c(); } function a() { b(); }a(); 代码执行的过程可以用动图表示：   call stack \nDOM和Web API JS对应的ECMA规范，V8只有堆和栈，用来实现ECMA规范，它与DOM（文档对象模型，其提供了一系列可以供JS调用的接口）、Web API、事件循环等执行环境如浏览器包含的内容不相关。 JS执行栈与渲染线程互相阻塞，为的是避免并行时JS获取DOM信息之后对DOM进行操作，而DOM本身同时也发生了变化，这样就会导致错乱和冲突。\n单线程同步、多线程同步、异步 fetchUserInfoSync().then(doSomethingA); // 1s fetchMyArcticlesSync().then(doSomethingB);// 3s fetchMyFriendsSync().then(doSomethingC);// 2s 在单线程的情况下，由于JS与渲染线程互相阻塞，因此发出三个接口异步请求时后续代码都被阻塞，数据需要耗时6s，这显然是不可接受的； 在多线程的情况下，最理想状态下需要耗时3s，但是因为三个线程都可以访问DOM和堆内存，很可能造成冲突，若要避免冲突就要设计锁🔒，这样会导致代码模型更加复杂，耗时必然大于3s； 在异步的情况下，就涉及到事件循环。\n事件循环如何实现异步 事件循环在浏览器和NodeJs中都是用于调度的，它决定了V8什么时候执行什么代码。V8只是负责JS代码的解析和执行，其他一概不知。 浏览器或者NodeJS中触发事件之后，到事件的监听函数被V8执行这个时间段的所有工作都是事件循环在起作用。 我们来小结一下：\n对于V8来说，它有： 调用栈（call stack） 这里的单线程指的是只有一个call stack。只有一个call stack 意味着同一时间只能执行一段代码。\n堆（heap） 对于浏览器运行环境来说： WEB API DOM API 任务队列 事件来触发事件循环进行流动\n事件循环之所以可以实现异步，就是将类似setTimeout等异步执行的代码注册/绑定的回调函数存起来，后面再将任务推入执行栈中。如图所示：\nfunction c() {} function b() { c(); } function a() { setTimeout(b, 2000) } a();   setTimeout \n加入用户交互之后，可见示例： http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\nsetTimeout代码执行后会将回调函数放入Web API中，计时结束后注册的回调函数会插入Callback queue中，待到Call Stack为空即浏览器空闲的时候时排队插入Call Stack被执行。\n加入宏任务和微任务，来看一个更复杂的例子：\nconsole.log(1) setTimeout(() =\u0026gt; { console.log(2) }, 0) Promise.resolve().then(() =\u0026gt; { return console.log(3) }).then(() =\u0026gt; { console.log(4) }) console.log(5) 上面的代码会输出：1、5、3、4、2。 如果你想要非常严谨的解释可以参考 whatwg 对其进行的描述 cievent-loop-processing-model。\n下面我会对其进行一个简单的解释。\n 浏览器首先执行宏任务，也就是我们script（仅仅执行一次） 完成之后检查是否存在微任务，然后不停执行，直到清空队列 执行宏任务 其中：  宏任务主要包含：setTimeout、setInterval、setImmediate、I/O、UI交互事件\n微任务主要包含：Promise、process.nextTick、MutaionObserver 等\n  事件循环示意图 \n有了这个知识，我们不难得出上面代码的输出结果。\n由此我们可以看出，宏任务\u0026amp;微任务只是实现异步过程中，我们对于信号的处理顺序不同而已。如果我们不加区分，全部放到一个队列，就不会有宏任务\u0026amp;微任务。这种人为划分优先级的过程，在某些时候非常有用。\n加入执行上下文栈 说到执行上下文，就不得不提到浏览器执行JS函数其实是分两个过程的。一个是创建阶段Creation Phase，一个是执行阶段Execution Phase。\n同执行栈一样，浏览器每遇到一个函数，也会将当前函数的执行上下文栈推入栈顶。\nfunction a(num) { function b(num) { function c(num) { const n = 3 console.log(num + n) } c(num); } b(num); } a(1); 遇到上面的代码。 首先会将a的压入执行栈，我们开始进行创建阶段Creation Phase， 将a的执行上下文压入栈。然后初始化a的执行上下文，分别是VO，ScopeChain（VO chain）和 This。 从这里我们也可以看出，this其实是动态决定的。VO指的是variables, functions 和 arguments。 并且执行上下文栈也会同步随着执行栈的销毁而销毁。\n伪代码表示：\nconst EC = { \u0026#39;scopeChain\u0026#39;: { }, \u0026#39;variableObject\u0026#39;: { }, \u0026#39;this\u0026#39;: { } }   execution context stack  我们来重点看一下ScopeChain(VO chain)。如上图的执行上下文大概长这个样子，伪代码：\nglobal.VO = { a: pointer to a(), scopeChain: [global.VO] } a.VO = { b: pointer to b(), arguments: { 0: 1 }, scopeChain: [a.VO, global.VO] } b.VO = { c: pointer to c(), arguments: { 0: 1 }, scopeChain: [b.VO, a.VO, global.VO] } c.VO = { arguments: { 0: 1 }, n: 3 scopeChain: [c.VO, b.VO, a.VO, global.VO] } 引擎查找变量的时候，会先从VOC开始找，找不到会继续去VOB…，直到GlobalVO，如果GlobalVO也找不到会返回Referrence Error，整个过程类似原型链的查找。\n值得一提的是，JS是词法作用域，也就是静态作用域。换句话说就是作用域取决于代码定义的位置，而不是执行的位置，这也就是闭包产生的本质原因。 如果上面的代码改造成下面的：\nfunction c() {} function b() {} function a() {} a() b() c() // 或者这种 function c() {} function b() { c(); } function a() { b(); } a(); 其执行上下文栈虽然都是一样的，但是其对应的scopeChain则完全不同，因为函数定义的位置发生了变化。拿上面的代码片段来说,c.VO会变成这样：\nc.VO = { scopeChain: [c.VO, global.VO] } 也就是说其再也无法获取到a和b中的VO了。 一图总结本文如下：   v8_engine.jpg \n参考资料： 《一文看懂浏览器事件循环》\n","date":"2020-12-28T12:03:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","title":"前端知识汇总（一）：浏览器事件模型和事件循环"},{"content":"项目结构优化 Vue Router 现在分为三个模块：\n History 实现： 处理地址栏，并且特定于 Vue Router 运行的环境（节点，浏览器，移动设备等） Router 匹配器：处理类似 /users/:id 的路由解析和优先级处理。 Router: 将一切连接在一起，并处理路由特定功能，例如导航守卫。  |____types | |____typeGuards.ts // 对route进行校验 | |____index.ts // type和interface |____router.ts // connects everything together and handle routing specific features like navigation guards |____RouterLink.ts |____errors.ts |____globalExtensions.ts |____injectionSymbols.ts |____utils | |____callbacks.ts | |____README.md | |____index.ts | |____env.ts |____devtools.ts |____location.ts |____matcher // handles the parsing of routes /users/:id and its ranking | |____pathTokenizer.ts // path解析器，生成token数组tokenizePath | |____pathMatcher.ts // 提供createRouteRecordMatcher方法供index调用，在addRoute时创建matcher | |____pathParserRanker.ts // 对每一个setment计算score | |____types.ts // 定义RouteRecordNormalized作为RouteRecord | |____index.ts // 定义并实现RouterMatcher，内部定义matcherMap路由映射；对RouteRecord、RouteProps进行normalize |____warning.ts |____RouterView.ts |____scrollBehavior.ts |____history // handles the address bar and is specific to the environment Vue Router runs on (Node, Browser, Mobile, etc) | |____common.ts // 列举一些通用的用于History API的interface、type、enum和在两个模式下通用的方法 | |____hash.ts // hash模式，createWebHashHistory | |____html5.ts // html5模式，createWebHistory | |____memory.ts // abstract模式，createMemoryHistory, 记录路由队列、监听器和当前位置，实现router方法。如果发现没有浏览器的 API，路由会自动强制进入这个模式 |____global.d.ts |____useApi.ts |____index.ts |____query.ts |____encoding.ts |____navigationGuards.ts // 路由守卫 // src/history/html5.ts /** * Creates a normalized history location from a window.location object * @param location - */ function createCurrentLocation( base: string, location: Location ): HistoryLocation {} function useHistoryListeners(base: string, historyState: ValueContainer\u0026lt;StateEntry\u0026gt;, currentLocation: ValueContainer\u0026lt;HistoryLocation\u0026gt;, replace: RouterHistory[\u0026#39;replace\u0026#39;] ){} function useHistoryStateNavigation(base: string) {} export function createWebHistory(base?: string): RouterHistory {} 动态路由 Vue Router3 { // 会匹配所有路径 path: '*' } { // 会匹配以 `/user-` 开头的任意路径 path: '/user-*' } vue-router 3使用 path-to-regexp 作为路径匹配引擎。 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。当使用通配符路由时，必须确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: \u0026lsquo;*\u0026rsquo; } 通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。\nVue Router 4 不再使用path-to-regexp，而是使用自己的转化系统。新增了有自动优先级排名的高级路径解析功能，用户新现在可以以随意的顺序定义路由，因为 Router 会根据 URL 字符串表示来猜测应该匹配的路由。 举个例子来说，你同时写了 /users 和 /:w+ 这两个路由：\nconst routes = [ { path: \u0026#39;/users\u0026#39;, Component: Users }, { path: \u0026#39;/:w+\u0026#39;, Component: NotFound } ] 那么你当然希望在输入 /users 这个更精确的路径的时候，走上面的规则，而下面则作为兜底规则。在旧版的 Vue Router 中需要通过路由声明的顺序来保证这个行为，而新版则无论你怎样放置，都会按照得分系统来计算该匹配哪个路由。\n甚至专门有 Path Ranker这个网页来帮助你计算路由的优先级得分。 简单来说，越明确的路由排名越高，越模糊则反之，无关顺序，非常有意思。\n改进后的导航系统 新的导航系统更加具有一致性，它改善了滚动行为的体验，使其更加接近原生浏览器的行为。 它还为用户提供了有关导航状态的几乎更多信息，用户可以用这些信息，通过 ProgressBar和 Modal之类的全局 UI 元素让用户的体验变得更好。 改进动机：\n 先前的selector默认使用document.querySelector。但是这个API不支持 /^#\\d/即以数字开头的id元素，所以vue3团队决定针对这种参数使用getElementById。但是这个API仍不适用于选择某个id元素内的某个class的元素，比如#1one .container。诸如此类的情况都会导致vue-router抛出document.querySelector failed，让用户产生困惑。  { x: number, y: number } { selector: string, offset? : { x: number, y: number }} 基于Element.scrollTo的参数配置ScrollToOptions，vue-router 4进行了改造  // vue router 3 scrollBehavior (to, from, savedPosition) { if (to.hash) { return { selector: to.hash } // return { x: 0, y: 200 }  } } // native JS element.scrollTo({ top: 100, left: 100, behavior: \u0026#39;smooth\u0026#39; }); // vue router 4 const router = new Router({ scrollBehavior(to, from, savedPosition) { // scroll to id `can~contain-special\u0026gt;characters` + 200px  return { el: \u0026#39;#can~contain-special\u0026gt;characters\u0026#39; // top relative offset  top: 200 // instead of `offset: { y: 200 }`  } } }) 更强大的 Devtools 多亏了新的Vue Devtools，Vue Router 能够和浏览器进行以下更高级的整合。\n 时间轴记录路由变化：   Timeline  完整 route 目录，能够帮助你轻松进行调试：   Routes directory   更好的路由守卫 beforeEach // BAD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) // 如果用户未能验证身份，则 `next` 会被调用两次  next() }) // GOOD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) else next() }) 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。 和next说拜拜，现在确认跳转不需要再手动执行这个函数了，而是根据你的返回值来决定行为。同样支持异步返回 Promise。\n现在的路由守卫 API 更加友好且合理了，可以完美利用 async await 做异步处理，比如这样：\nrouter.beforeEach(async (to, from) =\u0026gt; { // canUserAccess() returns `true` or `false`  return await canUserAccess(to) }) 路由独享的守卫 现在beforeEnter支持传入函数数组，便于复用，例如跳转到某个路由后自动去除所有query和hash\n// vue-router 3 const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, beforeEnter: (to, from, next) =\u0026gt; { // ...  } } ] }) // vue-router 4 function removeQueryParams(to) { if (Object.keys(to.query).length) return { path: to.path, query: {}, hash: to.hash } } function removeHash(to) { if (to.hash) return { path: to.path, query: to.query, hash: \u0026#39;\u0026#39; } } const routes = [ { path: \u0026#39;/users/:id\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams, removeHash], }, { path: \u0026#39;/about\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams], }, ] 迁移成本低 Vue Router 4 主要致力于于在改善现有 Router 的同时保持非常相似的 API，如果你已经很上手旧版的 Vue Router 了，那你的迁移会做的很顺利，可以查看文档中的完整迁移指南。\n展望未来 在过去的几个月中，Vue Router 一直稳定而且好用，现在它可以做些更好玩的事儿了：\n 使用现有工具（Vetur，Vite，Devtools 等）得到更好的开发体验。 与 Suspense 等现代功能更好地集成。 RFCs 和社区共同探讨出更好用的 API。 开发更轻型的版本。  Breaking Changes(partial) New history option to replace mode The mode: \u0026lsquo;history\u0026rsquo; option has been replaced with a more flexible one named history. Depending on which mode you were using, you will have to replace it with the appropriate function:\n \u0026ldquo;history\u0026rdquo;: createWebHistory() \u0026ldquo;hash\u0026rdquo;: createWebHashHistory() \u0026ldquo;abstract\u0026rdquo;: createMemoryHistory()  Here is a full snippet:\nimport { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; // there is also createWebHashHistory and createMemoryHistory  createRouter({ history: createWebHistory(\u0026#39;/base-directory/\u0026#39;), routes: [], }) Missing required params on named routes Pushing or resolving a named route without its required params will throw an error:\n// given the following route: const routes = [{ path: \u0026#39;/users/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: UserDetails }] // Missing the `id` param will fail router.push({ name: \u0026#39;user\u0026#39; }) router.resolve({ name: \u0026#39;user\u0026#39; }) 参考资料：\nVue Router 3.0 文档 Vue Router 4.0 release log\nVue Router 4.0 doc\nVue Router Migration Vue Router4 dynamic routing Routes' Matching Syntax router-scroll-position Path Ranker vue-router-next GitHub repo\n","date":"2020-12-13T19:23:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/vue-router-4.0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/vue-router-4.0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B/","title":"Vue Router 4.0特性简介"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]