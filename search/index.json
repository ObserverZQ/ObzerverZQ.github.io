[{"content":"flex: flex-grow flex-shrink flex-basis flex-grow 属性定义项目的放大比例，默认值为0，不放大，x为放大x倍 flex-shrink 属性定义了项目的缩小比例，默认值为1，空间不足即缩小，0是不缩小 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）。默认值为auto，项目默认的大小\n   语法 等于 描述 备注     flex: initial flex: 0 1 auto 容器默认不放大，尺寸不足会缩小，尺寸自适应内容 初始值   flex: 0 flex: 0 1 0% 默认放大，尺寸不足会缩小，大小支持0，即最小的内容尺寸 场景少   flex: none flex: 0 0 auto 默认不放大，尺寸不足也不缩小，子项的尺寸就是父级的尺寸时使用    flex: 1 flex: 1 1 0% 可以弹性变大，也可以弹性缩小，尺寸不足时优先最小化内容    flex: auto flex: 1 1 auto 可以弹性变大，也可以弹性缩小，尺寸不足时优先最大化内容 基于内容动态匹配    参考资料：\nFlex 布局教程：语法篇\n","date":"2021-03-09T10:14:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/flex%E5%B8%83%E5%B1%80/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/flex%E5%B8%83%E5%B1%80/","title":"flex布局"},{"content":"Vue的缺点： 全局的this Vue 2 html、data声明、涉及方法代码片段分散，可复用性差\n今日份吐血： 需要重复复制相同逻辑代码，功能代码分散 另一个页面需要使用，则需要复制相应的type action enum，\n上下文丢失 Vue 的单文件组件，使用 、对代码进行分割，直接导致的问题就是上下文丢失。 举个例子，你封装了一些常用的函数，在 Vue 文件中 import 进来。你这个函数能在 template 中直接使用吗？ 不能。 需要在data或者method中中再次声明。 或者用namespace直接定义好action mutation\n模板分割 好的代码组织能将常变与不变的部分进行分割解耦\nVue 的模板严重限制了这一点。 举个例子，前端有个下拉菜单，功能不断增加，而且对于不同的人要显示不同菜单（权限管理）。在 Vue 中，为了实现 html 代码（绑定在 template 中）的分割，你只能再搞一个组件。在 React 中，可以直接这样写：\nconst menu = \u0026lt;div\u0026gt;abc\u0026lt;div\u0026gt;; 可单独做一个组件（低开销函数组件），也可当做变量，放在当前代码中。相对灵活很多。 SX 手写 render 渲染函数自带下面的优势\n 完整的 js 功能来构建视图页面，可以使用临时变量、js 自带的控制流、以及直接引用当前 js 作用域中的值 开发工具对 jsx 的支持比现有 vue 模板先进（linting、typescript、编译器自动补全）  参考资料：\n为什么我们放弃了 Vue？Vue 和 React 深度对比\n","date":"2021-03-09T10:14:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","title":"Web UI 自动化测试实践"},{"content":"Selenium：可以直接在浏览器中运行，目前使用版本v3，最高版本v4（不稳定） 安装、运行：http://www.testclass.net/selenium_python/install-selenium 可能遇到浏览器驱动问题，https://blog.csdn.net/tymatlab/article/details/78649727 http://www.testclass.net/selenium_python/selenium3-browser-driver chrome驱动下载地址：https://sites.google.com/a/chromium.org/chromedriver/home\n元素定位：http://www.testclass.net/selenium_python/find-element 对项目元素设置不同的classsname、css选择器，即可通过以下方法获取到该元素\ndr.find_element_by_class_name(\u0026#34;s_ipt\u0026#34;) dr.find_element_by_css_selector(\u0026#34;#kw\u0026#34;) dr.find_element_by_css_selector(\u0026#34;[name=wd]\u0026#34;) dr.find_element_by_css_selector(\u0026#34;.s_ipt\u0026#34;) dr.find_element_by_css_selector(\u0026#34;html \u0026gt; body \u0026gt; form \u0026gt; span \u0026gt; input\u0026#34;) dr.find_element_by_css_selector(\u0026#34;span.soutu-btn\u0026gt; input#kw\u0026#34;) dr.find_element_by_css_selector(\u0026#34;form#form \u0026gt; span \u0026gt; input\u0026#34;) 控制浏览器操作： http://www.testclass.net/selenium_python/control-browser\n其余操作：包括鼠标事件、键盘事件、窗口切换、文件上传、关闭浏览器等 http://www.testclass.net/selenium_python\ncd ~ // 进入根目录 vim .bash_profile // 创建或者打开该文件\n// .bash_profile以及.bashrc以及.zshrc均输入以下内容 export M2_HOME=/Users/mtdp/project/apache-maven-3.6.3 // /Users/mtdp/project/apache-maven-3.6.3 这个路径是自己存放maven的路径 export M2=$M2_HOME/bin // 不动 export PATH=$M2:$PATH // 不动 export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home // 一般情况下只需要修改jdk版本号就好了，和自己安装的版本号一致，安装mvn和jdk后可以通过mvn -v查询到路径\n// 保存后使用source命令 source .bash_profile/.bashrc/.zshrc\n// java环境配置完成\n// 修改maven的setting文件。进入maven安装目录打开conf下面的settings文件\n 在自己的目录下新建java包存放文件夹，如maven_repostory，我的路径为/Users/mtdp/project/maven_repostory 打开settings.xml文件，修改localRepository路径  /Users/mtdp/project/maven_repostory// 改成自己的路径 meituan-nexus-releasesdeploymentdeployment123\u0026hellip; // 安装python，由于mac本来自带python2，但是如果使用不当可能会引起mac系统崩溃，因此我们使用python3 brew install python3 // 安装python3，如果没有安装brew，使用/bin/bash -c \u0026ldquo;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;安装HOMEbrew pip3 -V // 查看pip是否安装成功 pip3 install selenium // 使用piip安装selenium brew install chromedriver chromedriver \u0026ndash;version // 查看版本 // 我试着直接下载安装包过，但是path总是找不到，运行代码问题频频出现，因此选择命令安装 // 另外安装后一开始不生效的话，建议重开一个终端运行即可\n// 下载仓库代码 git clone ssh://git@git.sankuai.com/qa/case-uiauto.git\n// java运行，进入仓库代码中存放pom.xml层级的目录 mvn test -DxmlFileName=testng.xml\n// 默认用的是test环境， // 如果用本地分支跑，可以把testng.xml中detailUrl修改成localhost:8421/case/product/detail/1295217958986731508?fromRoute=createdCase\u0026amp;pageSize=10\u0026amp;keyword=UI%E8%87%AA%E5%8A%A8%E5%8C%96\u0026amp;offset=2\n测试场景梳理： UI自动化Demo运行需要搭建如下环境：jdk 1.8 + maven + Selenium WebDriver（Selenium 3） 参考资料：\nMac “\u0026lsquo;chromedriver\u0026rsquo; executable needs to be in PATH”\n","date":"2021-03-08T10:54:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","title":"Web UI 自动化测试实践"},{"content":"冒泡排序 基本思路：从左至右遍历数组，取一个指针指向第一个元素，与下一个元素比较，若该元素更大则前后交换位置，然后指针取下一位，与后一位进行比较，继续这样的循环，这样一轮下来会使得最大值放在数组的末尾，类似吐泡泡一样。之后重新开始循环上述过程，将第二大的元素放在倒数第二位。\nfunction bubbleSort(array) { let isSorted = true; let len = array.length; for (let i = 0; i \u0026lt; len; i ++) { for (let j = 0; （j \u0026lt; len - i - 1） \u0026amp;\u0026amp; array[j] \u0026gt; array[j + 1]; j++) { [array[j], array[j + 1]] = [array[j + 1], array[j]]; isSorted = false; } if (isSorted) { break; } } return array; } 时间复杂度上，最好情况是O(n)，即数组已经完全排好序，后一个元素永远比前一个元素大，不需要冒泡，只需要遍历一次，平均和最坏情况是O(n2)。\n选择排序 基本思路：从左至右遍历数组，比较一圈后得到最小值的索引，与索引0的元素交换位置；接着从第2位开始循环上述操作，将第二小的元素放在索引为1的位置，以此类推。每次遍历的时间为O(n)，这样的时间复杂度为O(n2)。\nfunction selectionSort(array) { for (let i = 0, len = array.length; i \u0026lt; len - 1; i++) { let min = i; for (let j = i + 1; j \u0026lt; len; j++) { if (array[j] \u0026lt; array[min]) { min = j; } } [array[i], array[min]] = [array[min], array[i]] } return array; } 时间复杂度上，最好、平均、最坏情况都是O(n2)。\n插入排序 基本思路：从左至右遍历，新元素通过与左边已经排好序的数组逐一比对，插入至左边的数组中，将比遍历到的元素大的元素统统右移一位。\nfunction insertionSort(array) { for (let i = 0, len = array.length; i++) { let j = i; const temp = array[j]; while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; array[j - 1]) { array[j] = array[j - 1]; j--; } array[j] = temp; } return array; } 时间复杂度上，最好情况为O(n)，即数组已经完全排好序，平均和最坏情况为O(n2)。\n下面进入到时间复杂度降低了的快速排序和归并排序。\n快速排序quicksort 法一 基本思路：选择一个基准值（随意选择），遍历数组（除基准值以外），将比基准值小的push到一个数组，放到基准值左侧，将比基准值大的push到另一个数组，放到基准值右侧，并对新的两个数组继续递归调用该函数，即为该函数的返回结果。基线条件为入参数组的长度为1，结束递归，直接返回该数组。递归过程逐个栈完成调用返回结果。\nfunction quickSort(array) { if (array.length \u0026lt; 2) { return array; } let pivot = array[0]; let low = []; let high = []; for (let i = 1; i \u0026lt; array.length; i++) { if (array[i] \u0026lt;= pivot) { low.push(array[i]); } else { high.push(array[i]); } } return quickSort(low).concat(pivot, quickSort(high)); } 每层实际还是遍历了O(n)个元素，而调用栈共有O(logn)层（相当于二分，所以是2的对数），所以平均情况的时间复杂度为O(n) * O(log n) = O(nlogn)。 最糟情况下，例如一个已经排好序的数组，基准值从第一个元素取，则右边分出来的数组拆分为原长度减1的数组，所以调用栈为n层，此时时间复杂度为O(n2)。但是一般都不会遇到最糟情况。\n法二 实现分析：\n将当前数组分区 分区时先选择一个基准值，再创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直至找到一个比基准值大的元素，再移动右指针直至找到一个比基准值小的元素，然后交换它们，重复这个过程，直到左指针的位置超过了右指针。如此分区、交换使得比基准值小的元素都在基准值之前，比基准值大的元素都在基准值之后，这就是分区（partition）操作。 对于上一次分区后的两个区域重复进行分区、交换操作，直至分区到最小。\nfunction quickSort(unsorted) { function partition(array, left, right) { const pivot = array[ Math.floor((left + right) / 2) ]; while (left \u0026lt;= right) { while (array[left] \u0026lt; pivot) { left++; } while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { [array[left], array[right]] = [array[right], array[left]]; left++; right--; } } return left; } function quick(array, left, right) { if (array.length \u0026lt;= 1) { return array; } const index = partition(array, left, right); if (left \u0026lt; index - 1) { quick(array, left, index - 1); } if (right \u0026gt; index) { quick(array, index, right); } return array; } return quick(unsorted, 0, unsorted.length - 1); } 时间复杂度上，最好、平均复杂度是O(nlogn)，最坏情况是O(n2)\n合并排序mergesort 基本思路：取位于数组中间的值，将左侧右侧各生成一个新数组（split），然后调用merge函数，各用一个索引进行逐个遍历比较，将较小的推送至结果数组中，直至其中一个数组遍历结束，对有剩余元素的那个数组在尾部加至结果数组。对新数组递归拆分操作，并调用该merge函数，直至左右数组的长度为0。\n将数组从中间切分为两个数组 切分到最小之后，开始归并操作，即合并两个已排序的数组 递归合并的过程，由于是从小到大合并，所以待合并的两个数组总是已排序的，一直做同样的归并操作就可以\nfunction mergeSort(array) { function merge(arrL, arrR) { let indexL = indexR = 0; const lenL = arrL.length; const lenR = arrR.length; const result = []; while (indexL \u0026lt; lenL \u0026amp;\u0026amp; indexR \u0026lt; lenR) { if (arrL[indexL] \u0026lt;= arrR[indexR]) { result.push(arrL[indexL++]); } else { result.push(arrR[indexR++]); } } while (indexL \u0026lt; lenL) { result.push(arrL[indexL++]) } while (indexR \u0026lt; lenR) { result.push(arrR[indexR++]) } return result; } function split(array) { const len = array.length / 2 let mid = Math.floor(len); const arrL = array.slice(0, mid); const arrR = array.slice(mid, len); return merge(split(arrL), split(arrR)); } return split(array); } 时间复杂度上，最好、平均和最坏情况都是 O(nlog(n))。\n对比归并排序与快速排序  都用了分治的思想。相比选择排序和冒泡排序，归并排序与快速排序使用了切分而不是直接遍历，这有效减少了交换次数。 归并排序是先切分、后排序，过程可以描述为：切分、切分、切分……排序、排序、排序…… 快速排序是分区、排序交替进行，过程可以描述为：分区、排序、分区、排序…… 上两条所说的“排序”，在归并排序与快速排序中并非同样的操作，归并排序中的操作是将两个数组合并为一（归并操作），而快速排序中的操作是交换。 归并排序，由小及大，小的排好序的数组递归合并为大的排好序的数组，逐渐递归覆盖到整个原始数组；快速排序，由大及小，先将大的整个数组根据基准值进行大小分区，再逐渐切小，对小的分区进行大小分区。  以上集中排序方式的时间复杂度和空间复杂度如下图所示：   sorting algorithm  空间复杂度分析：\n堆排序：todo 树排序：todo\n参考资料： 归并排序与快速排序的简明实现及对比\n","date":"2021-02-26T19:11:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/array_sorting_algorithm_huec1666719498bd6a587a8e0b2a8ad6f2_69768_120x120_fill_box_smart1_2.png","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"JavaScript实现常见排序算法"},{"content":"临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。\n为帮助 Node.js 开发人员更好的面试，我列出了 15 个常见的 Node.js 和网络开发相关的面试问题。\n在本文中，我们将重点讨论 Node.js 相关问题。但是，请记住 JavaScript 问题在 Node.js 面试中也经常问到，所以准备一些对你来说没什么坏处。不久前我们写了一篇关于常见 JavaScript 面试问题的帖子，涵盖了所有这些基础。\nhttps://livecodestream.dev/post/20-common-javascript-interview-questions/\n现在，让我们深入了解面试中可能会问到的 Node.js 问题。\n Node.js 与 JavaScript 有什么不同?    Image \n什么时候用 Node.js？ Node.js 是异步的、事件驱动的、非阻塞的和单线程的，使得它成为开发下面应用程序的完美候选：    实时应用程序，如聊天和提供实时更新的应用程序\n  将视频或其他多媒体内容流式传输给大量观众的流式应用程序\n  其他 I/O 密集型应用程序，如协作平台\n  遵循微服务架构的网络后端\n  然而，Node.js 的特性使得它对于其他类型的应用程序来说不是一个理想的选择。执行 CPU 密集型任务的应用程序（如复杂的数学计算）在使用 CPU 时表现不佳，因为 Node.js 是单线程的。\nEventEmitter 做了什么？ Node.js 中任何对象发出的事件都是 EventEmitter 类的实例，就像 http 模块。  所有 EventEmitter 类都可以使用 eventEmitter.on() 函数将事件侦听器附加到事件。然后一旦捕捉到这样的事件，就会同步地逐个调用它的侦听器。\nconst events = require(\u0026#34;events\u0026#34;); const eventEmitter = new events.EventEmitter(); const eventListener = function(){ console.log(\u0026#34;event triggered\u0026#34;); } eventEmitter.on(\u0026#34;emitted\u0026#34;, eventListener); eventEmitter.emit(\u0026#34;emitted\u0026#34;); 事件循环是什么?  单线程的 Node.js 必须是非阻塞的，以防止线程阻塞在需要很长时间才能完成的任务上，事件循环负责实现这种非阻塞行为，它使用应用程序线程调度挂起的任务。\nNode.js 在任务完成时通过回调来处理异步函数返回的响应。与创建任务的事件类似，任务完成后也会发出一个事件。Node.js 将需要处理的事件添加到事件队列。\n事件循环对事件队列中的事件进行迭代，并安排何时执行其关联的回调函数。\n流是什么?  Stream 流是从源读取或写入数据并将其传输到连续流目标的管道。有四种类型：\n  可读\n  可写的\n  可读写\n  先写入，再读出来\n  每个流也是一个 EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件。\nconst fs = require(\u0026#34;fs\u0026#34;); const readableStream = fs.createReadStream(\u0026#34;test.txt\u0026#34;); let content = \u0026#34;\u0026#34;; readableStream.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { content += chunk; }); readableStream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(content); }); readFile 和 createReadStream 函数有什么区别？  readFile 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。\ncreateReadStream 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。\n与 readFile 相比，createReadStream 使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会先向用户发送小块内容。\nconst fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#34;test.txt\u0026#34;, (err, content) =\u0026gt; { console.log(content); }); 如何处理 Node.js 中未捕获的异常？  我们可以在进程级别捕获应用程序中未捕获的异常。为此将侦听器附加到 process 全局对象：\nprocess.on(\u0026#34;uncaughtException\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;exception caught: \u0026#34;, err); }); Node.js 能否充分利用多核处理器？ （默认的）Node.js 应用程序总是单线程的，即使在多核处理器上运行，应用程序也能只使用一个处理器。  但是 Node.js 的核心模块之一 Cluster 支持 Node.js 应用程序开启多核，允许我们创建多个工作进程，这些进程可以在多个内核上并行运行，并共享一个端口来侦听事件。\n每个进程使用 IPC 与主线程通信，并根据需要将服务器句柄传递给其他进程。主进程可以侦听端口本身并以循环方式将每个新连接传递给子进程，也可以将端口分配给子进程以便子进程侦听请求。\n反应堆设计模式是什么？ 反应堆设计模式是，Node.js 将回调函数（处理程序）附加到每个 I/O 操作，然后创建请求时将处理程序提交给解复用器。  解复用器收集应用程序中发出的每个 I/O 请求，并将它们作为队列中的事件进行排队。这个队列就是我们所说的事件队列。将事件排队后，解复用器返回应用程序线程的控制。\n同时，事件循环遍历事件队列中的每个事件，并调用附加的回调来处理事件响应。\n这就是 Node.js 中所使用的反应堆模式。\n单线程与多线程网络后端相比有哪些好处？  尽管 Node.js 是单线程的，但是大多数用于后端开发的编程语言都提供多线程来处理应用程序操作。而为什么单线程有利于后端开发？\n开发人员更容易实现应用程序。我们的应用程序在生产过程中不会突然遇到意外的竞争条件。\n单线程应用程序易于扩展。\n它们可以毫不延迟地在一个时刻收到的大量用户请求提供服务。相比之下，当流量较大时，多线程后端必须等待线程池中的线程释放，才能为用户请求提供服务。利用 Node.js 的非阻塞特性，用户请求不会在单个线程上挂起太长时间（只有在操作不是 CPU 密集型时）。\nREPL 是什么？  REPL 代表 Read Eval Print Loop，是一个虚拟环境，可以在其中轻松地运行编程语言。Node.js 带有一个内置的 REPL 来运行 JavaScript 代码，类似于我们在浏览器中用来运行 JavaScript 代码的控制台。\n要启动 Node.js REPL，只需在命令行上运行 node，然后写一行 JavaScript 代码，就可以在下一行看到它的输出。\nprocess.nextTick 和 setImmediate 有什么区别？ 传递给 setImmediate 函数的回调将在事件队列上的下一次迭代中执行。  另一方面，回调传递给 process.nextTick 在下一次迭代之前以及程序中当前运行的操作完成之后执行。在应用程序启动时，开始遍历事件队列之前调用它的回调。\n因此，回调 process.nextTick 总是在 setImmediate 之前调用。\n下面代码段：\nsetImmediate(() =\u0026gt; { console.log(\u0026#34;first\u0026#34;); }) process.nextTick(() =\u0026gt; { console.log(\u0026#34;second\u0026#34;); }) console.log(\u0026#34;third\u0026#34;); 将按顺序输出： third second first 13. stub 是什么? 测试应用程序时使用 stub，模拟给定组件或模块的行为，你可以将精力集中在要测试的代码部分。通过使用 stub 代替与测试无关的组件，不必担心外部组件会影响结果。\n例如，如果正在测试的组件在预期测试的部分之前有一个文件读取操作，则可以使用 stub 来模拟该行为并返回模拟内容，而不用实际读取文件。\n在 Node.js 中，我们使用像 Sinon 这样的库来实现（译者注，Sinon 在测试中替换某部分代码，减少测试项编写的复杂度 https://sinonjs.org）。\n为什么在 express 中分离“应用程序”和“服务器”是一种好的做法？ 通过在 Express 中分离应用程序和服务器，可以将 API 实现与网络相关配置分开。在不执行网络调用的情况下执行 API 测试，保证了更快的测试执行和更好的代码覆盖度量。  要实现这种分离，应该在单独的文件中声明 API 和 server，对应 app.js 和 server.js：\n// app.js const express = require(\u0026#34;express\u0026#34;); const app = express(); app.use(\u0026#34;/\u0026#34;, index); app.use(\u0026#34;/contact\u0026#34;, contact); app.use(\u0026#34;/user\u0026#34;, user); module.exports = app; // server.js const http = require(\u0026#34;http\u0026#34;); const app = require(\u0026#34;/app\u0026#34;); app.set(\u0026#39;port\u0026#39;, process.env.PORT); const http = http.createServer(app); 什么是 yarn 和 npm？为什么要用 yarn 代替 npm 呢？ npm 是与 Node.js 自带的默认包管理器，它有一个大型的公共库和私有库，存储在 npm registry 的数据库中（译者注，官方默认中心库 http://registry.npmjs.org/，国内淘宝镜像 http://registry.npm.taobao.org/），用户可以通过 npm 命令行访问该数据库。在 npm 的帮助下，用户可以轻松管理项目中的依赖项。  yarn 也是一个包管理器，为了解决 npm 的一些缺点。yarn 依赖 npm 注册中心为用户提供对包访问。yarn 底层结构基于 npm，如果从 npm 迁移到 yarn，项目结构和工作流不需要大改。\n就像之前提到的，在某些情况下，yarn 提供了比 npm 更好的功能。与 npm 不同的是，它会缓存下载的每个包，不必重新下载。\n通过校验和验证包的完整性来提供更好的安全性，保证在某个系统上运行的包在任何其他系统中的工作方式完全相同，这就是为什么选择 yarn 而不是 npm 来进行包管理。\n结论 在本文中，讨论了 15 个最常见的 Node.js 面试问题，帮助你为下一次面试做准备。知道你可能被问到的问题和答案，面试就不再紧张了。\n祝你好运，面试成功！临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。\n参考资料：\n15 个常见的 Node.js 面试问题及答案\n","date":"2021-02-22T19:23:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/node.js-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%9815%E6%9D%A1/640_hu992ded1d4f7b7b2034fd8a8bad8be327_108856_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/node.js-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%9815%E6%9D%A1/","title":"Node.js 常见问题15条"},{"content":"  自我介绍的模板 突出能力 ✅\n突出兴趣 突出性格\n之后！！！重要！！！！对自己进行总结+求职意向的说明\n  申请岗位的理由，有自己的话复述一下岗位要求： 看好行业岗位前景/我的个人兴趣/非常适合发挥我的能力\n  结合自己的介绍，阐述自己为什么适合这个岗位，总结匹配性 我过去的经历，已经储备了xx能力（重复一下具体能力名称），我自己也是一个xx的人（具体的性格特点价值观） 我觉得xx的经历对我申请这个岗位有很大帮助（引导面试官后续询问亮点经历）。除了工作之外，我平时还喜欢xx，也对我申请这个岗位有帮助。（爱好、兴趣，能够说明你的性格特点价值观，切记匹配岗位要求）\n  自我介绍要点： 3分钟串联经历，给经历做总结，最后重申自己为什么申请这个岗位，为什么适合这个岗位。\n  详细介绍过往经历 面试官可能会问：详细介绍一下你在xx的工作经历？能具体介绍一下xx项目的过程吗？ ！！！拒绝流水账！！！重点是展示具体能力、工作方法和态度、特长 这里可以运用STAR原则 situation task action reuslt\n(1) 情景 —— 这个情景有多重要？ 面试官会根据这个判断你是否收到重用。 可以增加以下表述： 我所在的这个组是公司当时重点发力的部门/公司主营业务部门； 我们这个项目当时是为了解决平台的新增xx需求\n岗位如下三类，可以进行下下归类： 主营业务岗位/主营业务相关项目 —— 公司当下最重要的部门 创新业务线/创新项目 —— 公司的未来 业务核心支撑部门 —— 稳定性、持续性的部门\n(2) 任务 —— 你的任务独特性是什么？ 任务的独特性能够通过过往经历更好地体现你的能力、性格、价值观。独特性主要分为以下三种： 独立完成型 —— 独自承担某项工作，要介绍细节 （能力认可） 横向对比型 —— 同样类型工作，和其他同事比，特色之处 （优势） 体现能力型 —— 对难点进行抽象，协调能力/短时间高强度/认真细致/快速学习\n(3) 行动 —— 你工作的亮点是什么？ 亮点大致可以分为以下五种： 高举高打型 —— 专业、深度、超越同级别/年龄工作者的方法 努力拼搏型 —— 花时间、精力 独立思考型 —— 用和别人不同的方式 善用资源型 —— 解决问题，借助外部资源 克服困难型 —— 突出任务中的矛盾，体现自己能力\n(4) 结果 —— 有多超预期？ 不要出现假大空的词汇，例如 大量、很多、显著、广泛、非常，尽量使用具体数字、事实，并且要给一个参照系\n  和自己比 系统效率提升了xx，收入提升了xx，费率降低了xx，超额完成KPIxx 和别人比 排名前xx%，比别人快xx%\n  额外价值 优化了流程，标准化了工序，自动化了工作，开辟新渠道，学习了xx技能\n  总结要点：STAR结构化阐述，S突出重要性，T突出独特性，A突出亮点，R突出超预期。\n  如何回答专业问题 (1) 有标准答案的问题 首先基础知识、题库刷起来！ 考验临场表现的难题： a。 10秒想不出来的问题，先套话。 “这个问我我需要组织一下思路/思考一下/回忆一下/准备一下” 三个要点：\n 正视面试官 —— 表现冷静 笔记本 —— 写写画画，减压 思考不超过30秒 —— 避免空气凝固  b。表示不知道，但是知道答案的大概范围/思路 让面试官了解到虽然暂时回答不上来，但是知道是哪个领域的，回去补课的话可以掌握。\nc。表示不知道，但是可以回答类似问题，并且给出答案 xxx不太熟悉，用的比较少，我用过其他xxx，可以介绍一下吗？ —— 考察知识技能之外，还看表达能力、逻辑性，避免被动地被面试官发现更多不熟悉\n(2) 开放性问题 主要考察表达、逻辑、沟通、知识深度和广度。 三个要点：\n 垫话 “稍微准备一下” 然后把要点写在笔记本上。这样可以进行缓冲 用词专业 回答时尽量用专业术语 提前准备面经 把所有真题都认真吸收。开放性问题要自己尝试写答案，掌握方法而不是死记硬背。    如何回答个人问题 (1) 为什么离开上一家？ ❌ 毫无主见型 大家都。。。 ❌ 抱怨型 没发展。。气氛差。。 ✅ 前景美好型 公司的美好前景+具体细节 公司的发展势头 市场快速发展 公司战略明确，对员工更有上升空间 公司技术/商业模式更好 岗位需求在扩大 学到/得到更多知识或者经验\n✅ 个人兴趣型 公司的xx + 详细解释 贵公司的工作内容 贵公司岗位使用的技术 贵公司的工作节奏、气氛\n✅ 发挥价值型 我的技术/知识/背景/性格 + 算账/对比\n(2) 自我评价 优缺点/你是个什么样的人？\n第一，先认真评价一下自己 回顾bbc 第二，找一下目标公司、目标岗位需要什么样的人 JD中都会提到，对比一下。软性实力、个人特点和岗位是否匹配？ 第三，取交集\n谈个人特点、优点，可以使用三段论： 我是一个xx的人，xxx比较强，xxx是我的一个优点。 —— 结论 比如我之前xxx，我平时xxx —— 事实支撑，更可信 在这个岗位上，我能发挥/适应/解决xxx —— 强化你的优点与目标岗位需求的关系\n如果明确问了缺点？ ❌ 过分实在型 粗心、情绪起伏大。。。 ❌ 明贬暗褒型 工作太拼。。。 ❌ 避重就轻型 不注意着装。。。 ❌ 答不出来型 。。。。\n✅ 主要工作的次要技能，说自己有待提高。 介绍背景+主要矛盾的次要方面。 作为xxx，xxx比较扎实，但是对xxx这块不是很熟悉。 我也在多和同时学习，提升这部分能力。\n✅ 用详细的描述让缺点变成特点 特点+具体场景+解决方案\n(3) 职业规划 短期职业规划是面试官最关心的。需要体现稳定性。 实现的目标短期掌握哪些能力、解决什么问题、成为哪一种更高职位的人才 看一看比自己高1-2个职级的人。再看JD。和业内资深人士交流。 提高或者实现的路径 工作中学习哪些技能、提升经验、业余时间如何提高，展示未来3-5年的成长思路。如果很清楚短板，就具体描述如何提高短板。\n重点：目标明确、路径清晰。这会向面试官展示出稳定性、成长性。 我希望xx年后可以开始独立负责xx项目 —— 明确目标 短期内我会xxx，xxx。xxx。 —— 路径\n(4) 其他问题 注意回答问题要和之前体现出的个人性格、价值观、自我介绍保持一致。\n  如何给公司提问题 ！！不要问公开可以搜索到的问题 非HR：职业发展的路径，工作氛围，团队工作节奏 部门在公司定位 战略级产品类型 技术栈 具体分工 部门发展规划 主要客户群体\n反馈或追问 对个人提升的关心 入职后培训体系 职业发展路径 今生 未来1年什么成果\n结合自己的背景 进行追问/反馈。\n  除了当场面试之外的三个细节 (1) 排练 语速适中 声音适中 音调适中 平视 目光正直 身体不要乱动 (2) 面试当天 早去 熟悉场地气氛 找人闲聊 前台、HR、其他面试者，进入与人沟通的情景 临走留个联系方式，加微信 表示感谢 询问是否需要补充材料 录取了：提前聊一聊 没录取：打个招呼，再次感谢 (3)\n  ","date":"2021-01-12T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/ji%E6%8A%80%E5%B7%A7/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/ji%E6%8A%80%E5%B7%A7/","title":"JI技巧"},{"content":"WebSocket 工作在七层（或者四层）中的哪一层？和 HTTP 是什么关系？ 是基于 UDP 的还是 TCP 的？ TCP 为什么是三次握手？为什么是四次挥手？ CDN 的工作原理是什么？ 运营商劫持是什么？如何防范？ HTTPS 一定是安全的么？如果不是，那么在什么情况下是不安全的？ 如何劫持 HTTPS 请求。 比如你需要抓 HTTPS 的包，怎么做？ 支付宝和微信的离线支付是怎么做的？ Token 和 Cookie 有什么区别和联系呢？其分别是为了解决什么样的事情？ WebSocket 需要 cookie 么？为什么？ WebSocket 是怎么实现点对点通信和广播通信的？ 如果访问你的 APP 很慢，你自己无法重现。 初步定位到网络问题， 那么你怎么能具体定位到问题呢？ traceroute, Ping 的原理是什么？ 192.168.0.1 和 192.168.1.1 如何通信？ DNS 是如何泄漏个人隐私的？怎么防范？ 从网络协议模型（七层 or 四层）的角度分析一下，浏览器访问 192.168.3.4:8088 的具体过程。\n","date":"2021-01-12T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BA%8C%E7%BD%91%E7%BB%9C/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BA%8C%E7%BD%91%E7%BB%9C/","title":"前端知识汇总（二）：网络"},{"content":"事件模型 不论是浏览器还是Node.js，都有自己的事件模型，它们都是事件驱动的，即依靠事件来维持运行。 现在比较推荐的绑定事件的方法是addEventListener：\ntarget.addEventListener(type, listener[, options]); target.addEventListener(type, listener[, useCapture]); target.addEventListener(type, listener[, useCapture, wantsUntrusted ]); // Gecko/Mozilla only 旧版本的第三个参数是bool，表示是否是捕获阶段，默认是false，即默认为冒泡阶段。新版本是一个对象，其中有capture（和上面功能一样），passive和once。once用来执行是否只执行一次，passive如果被指定为true, 表示永远不会执行preventDefault(),这在实现丝滑柔顺的滚动的效果中很重要。Improving scrolling performance with passive listeners\n框架中的事件 框架中的事件 实际上，我们现在大多数情况都是用框架来写代码，因此上面的情况其实在现实中是非常少见的，我们更多看到的是框架封装好的事件，比如React的合成事件，感兴趣的可以看下这几篇文章。\n React SyntheticEvent Vue和React的优点分别是什么？两者的最核心差异对比是什么？  虽然我们很少时候会接触到原生的事件，但是了解一下事件对象，事件机制，事件代理等还是很有必要的，因为框架的事件系统至少在这方面还是一致的，这些内容我们接下来就会讲到。\n事件对象 function handleClick(e: Event) { // ... } 这个e就是事件对象，它包含一些重要属性和方法：\n 属性   target x, y等位置信息 timeStamp eventPhase   方法   preventDefault 用于阻止浏览器的默认行为，比如a标签会默认进行跳转，form会默认校验并发送请求到action指定的地址等 stopPropagation 用于阻止事件的继续冒泡行为，后面讲事件传播的时候会提到。  事件循环 事件指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。循环指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。 一段JS代码，需要被编译成机器可理解并执行的指令，这就依赖JS引擎。而V8引擎中，有两个核心组成，即执行栈和堆。执行栈中存放正在执行的代码段，堆中存放变量的值。以一段简单代码为例：\nfunction c() {} function b() { c(); } function a() { b(); }a(); 代码执行的过程可以用动图表示：   call stack \nDOM和Web API JS对应的ECMA规范，V8只有堆和栈，用来实现ECMA规范，它与DOM（文档对象模型，其提供了一系列可以供JS调用的接口）、Web API、事件循环等执行环境如浏览器包含的内容不相关。 JS执行栈与渲染线程互相阻塞，为的是避免并行时JS获取DOM信息之后对DOM进行操作，而DOM本身同时也发生了变化，这样就会导致错乱和冲突。\n单线程同步、多线程同步、异步 fetchUserInfoSync().then(doSomethingA); // 1s fetchMyArcticlesSync().then(doSomethingB);// 3s fetchMyFriendsSync().then(doSomethingC);// 2s 在单线程的情况下，由于JS与渲染线程互相阻塞，因此发出三个接口异步请求时后续代码都被阻塞，数据需要耗时6s，这显然是不可接受的； 在多线程的情况下，最理想状态下需要耗时3s，但是因为三个线程都可以访问DOM和堆内存，很可能造成冲突，若要避免冲突就要设计锁🔒，这样会导致代码模型更加复杂，耗时必然大于3s； 在异步的情况下，就涉及到事件循环。\n事件循环如何实现异步 事件循环在浏览器和NodeJs中都是用于调度的，它决定了V8什么时候执行什么代码。V8只是负责JS代码的解析和执行，其他一概不知。 浏览器或者NodeJS中触发事件之后，到事件的监听函数被V8执行这个时间段的所有工作都是事件循环在起作用。 我们来小结一下：\n对于V8来说，它有： 调用栈（call stack） 这里的单线程指的是只有一个call stack。只有一个call stack 意味着同一时间只能执行一段代码。\n堆（heap） 对于浏览器运行环境来说： WEB API DOM API 任务队列 事件来触发事件循环进行流动\n事件循环之所以可以实现异步，就是将类似setTimeout等异步执行的代码注册/绑定的回调函数存起来，后面再将任务推入执行栈中。如图所示：\nfunction c() {} function b() { c(); } function a() { setTimeout(b, 2000) } a();   setTimeout \n加入用户交互之后，可见示例： http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\nsetTimeout代码执行后会将回调函数放入Web API中，计时结束后注册的回调函数会插入Callback queue中，待到Call Stack为空即浏览器空闲的时候时排队插入Call Stack被执行。\n加入宏任务和微任务，来看一个更复杂的例子：\nconsole.log(1) setTimeout(() =\u0026gt; { console.log(2) }, 0) Promise.resolve().then(() =\u0026gt; { return console.log(3) }).then(() =\u0026gt; { console.log(4) }) console.log(5) 上面的代码会输出：1、5、3、4、2。 如果你想要非常严谨的解释可以参考 whatwg 对其进行的描述 cievent-loop-processing-model。\n下面我会对其进行一个简单的解释。\n 浏览器首先执行宏任务，也就是我们script（仅仅执行一次） 完成之后检查是否存在微任务，然后不停执行，直到清空队列 执行宏任务 其中：  宏任务主要包含：setTimeout、setInterval、setImmediate、I/O、UI交互事件\n微任务主要包含：Promise、process.nextTick、MutaionObserver 等\n  事件循环示意图 \n有了这个知识，我们不难得出上面代码的输出结果。\n由此我们可以看出，宏任务\u0026amp;微任务只是实现异步过程中，我们对于信号的处理顺序不同而已。如果我们不加区分，全部放到一个队列，就不会有宏任务\u0026amp;微任务。这种人为划分优先级的过程，在某些时候非常有用。\n加入执行上下文栈 说到执行上下文，就不得不提到浏览器执行JS函数其实是分两个过程的。一个是创建阶段Creation Phase，一个是执行阶段Execution Phase。\n同执行栈一样，浏览器每遇到一个函数，也会将当前函数的执行上下文栈推入栈顶。\nfunction a(num) { function b(num) { function c(num) { const n = 3 console.log(num + n) } c(num); } b(num); } a(1); 遇到上面的代码。 首先会将a的压入执行栈，我们开始进行创建阶段Creation Phase， 将a的执行上下文压入栈。然后初始化a的执行上下文，分别是VO，ScopeChain（VO chain）和 This。 从这里我们也可以看出，this其实是动态决定的。VO指的是variables, functions 和 arguments。 并且执行上下文栈也会同步随着执行栈的销毁而销毁。\n伪代码表示：\nconst EC = { \u0026#39;scopeChain\u0026#39;: { }, \u0026#39;variableObject\u0026#39;: { }, \u0026#39;this\u0026#39;: { } }   execution context stack  我们来重点看一下ScopeChain(VO chain)。如上图的执行上下文大概长这个样子，伪代码：\nglobal.VO = { a: pointer to a(), scopeChain: [global.VO] } a.VO = { b: pointer to b(), arguments: { 0: 1 }, scopeChain: [a.VO, global.VO] } b.VO = { c: pointer to c(), arguments: { 0: 1 }, scopeChain: [b.VO, a.VO, global.VO] } c.VO = { arguments: { 0: 1 }, n: 3 scopeChain: [c.VO, b.VO, a.VO, global.VO] } 引擎查找变量的时候，会先从VOC开始找，找不到会继续去VOB…，直到GlobalVO，如果GlobalVO也找不到会返回Referrence Error，整个过程类似原型链的查找。\n值得一提的是，JS是词法作用域，也就是静态作用域。换句话说就是作用域取决于代码定义的位置，而不是执行的位置，这也就是闭包产生的本质原因。 如果上面的代码改造成下面的：\nfunction c() {} function b() {} function a() {} a() b() c() // 或者这种 function c() {} function b() { c(); } function a() { b(); } a(); 其执行上下文栈虽然都是一样的，但是其对应的scopeChain则完全不同，因为函数定义的位置发生了变化。拿上面的代码片段来说,c.VO会变成这样：\nc.VO = { scopeChain: [c.VO, global.VO] } 也就是说其再也无法获取到a和b中的VO了。 一图总结本文如下：   v8_engine.jpg \n参考资料： 《一文看懂浏览器事件循环》\n","date":"2020-12-28T12:03:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","title":"前端知识汇总（一）：浏览器事件模型和事件循环"},{"content":"项目结构优化 Vue Router 现在分为三个模块：\n History 实现： 处理地址栏，并且特定于 Vue Router 运行的环境（节点，浏览器，移动设备等） Router 匹配器：处理类似 /users/:id 的路由解析和优先级处理。 Router: 将一切连接在一起，并处理路由特定功能，例如导航守卫。  |____types | |____typeGuards.ts // 对route进行校验 | |____index.ts // type和interface |____router.ts // connects everything together and handle routing specific features like navigation guards |____RouterLink.ts |____errors.ts |____globalExtensions.ts |____injectionSymbols.ts |____utils | |____callbacks.ts | |____README.md | |____index.ts | |____env.ts |____devtools.ts |____location.ts |____matcher // handles the parsing of routes /users/:id and its ranking | |____pathTokenizer.ts // path解析器，生成token数组tokenizePath | |____pathMatcher.ts // 提供createRouteRecordMatcher方法供index调用，在addRoute时创建matcher | |____pathParserRanker.ts // 对每一个setment计算score | |____types.ts // 定义RouteRecordNormalized作为RouteRecord | |____index.ts // 定义并实现RouterMatcher，内部定义matcherMap路由映射；对RouteRecord、RouteProps进行normalize |____warning.ts |____RouterView.ts |____scrollBehavior.ts |____history // handles the address bar and is specific to the environment Vue Router runs on (Node, Browser, Mobile, etc) | |____common.ts // 列举一些通用的用于History API的interface、type、enum和在两个模式下通用的方法 | |____hash.ts // hash模式，createWebHashHistory | |____html5.ts // html5模式，createWebHistory | |____memory.ts // abstract模式，createMemoryHistory, 记录路由队列、监听器和当前位置，实现router方法。如果发现没有浏览器的 API，路由会自动强制进入这个模式 |____global.d.ts |____useApi.ts |____index.ts |____query.ts |____encoding.ts |____navigationGuards.ts // 路由守卫 // src/history/html5.ts /** * Creates a normalized history location from a window.location object * @param location - */ function createCurrentLocation( base: string, location: Location ): HistoryLocation {} function useHistoryListeners(base: string, historyState: ValueContainer\u0026lt;StateEntry\u0026gt;, currentLocation: ValueContainer\u0026lt;HistoryLocation\u0026gt;, replace: RouterHistory[\u0026#39;replace\u0026#39;] ){} function useHistoryStateNavigation(base: string) {} export function createWebHistory(base?: string): RouterHistory {} 动态路由 Vue Router3 { // 会匹配所有路径 path: '*' } { // 会匹配以 `/user-` 开头的任意路径 path: '/user-*' } vue-router 3使用 path-to-regexp 作为路径匹配引擎。 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。当使用通配符路由时，必须确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: \u0026lsquo;*\u0026rsquo; } 通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。\nVue Router 4 不再使用path-to-regexp，而是使用自己的转化系统。新增了有自动优先级排名的高级路径解析功能，用户新现在可以以随意的顺序定义路由，因为 Router 会根据 URL 字符串表示来猜测应该匹配的路由。 举个例子来说，你同时写了 /users 和 /:w+ 这两个路由：\nconst routes = [ { path: \u0026#39;/users\u0026#39;, Component: Users }, { path: \u0026#39;/:w+\u0026#39;, Component: NotFound } ] 那么你当然希望在输入 /users 这个更精确的路径的时候，走上面的规则，而下面则作为兜底规则。在旧版的 Vue Router 中需要通过路由声明的顺序来保证这个行为，而新版则无论你怎样放置，都会按照得分系统来计算该匹配哪个路由。\n甚至专门有 Path Ranker这个网页来帮助你计算路由的优先级得分。 简单来说，越明确的路由排名越高，越模糊则反之，无关顺序，非常有意思。\n改进后的导航系统 新的导航系统更加具有一致性，它改善了滚动行为的体验，使其更加接近原生浏览器的行为。 它还为用户提供了有关导航状态的几乎更多信息，用户可以用这些信息，通过 ProgressBar和 Modal之类的全局 UI 元素让用户的体验变得更好。 改进动机：\n 先前的selector默认使用document.querySelector。但是这个API不支持 /^#\\d/即以数字开头的id元素，所以vue3团队决定针对这种参数使用getElementById。但是这个API仍不适用于选择某个id元素内的某个class的元素，比如#1one .container。诸如此类的情况都会导致vue-router抛出document.querySelector failed，让用户产生困惑。  { x: number, y: number } { selector: string, offset? : { x: number, y: number }} 基于Element.scrollTo的参数配置ScrollToOptions，vue-router 4进行了改造  // vue router 3 scrollBehavior (to, from, savedPosition) { if (to.hash) { return { selector: to.hash } // return { x: 0, y: 200 }  } } // native JS element.scrollTo({ top: 100, left: 100, behavior: \u0026#39;smooth\u0026#39; }); // vue router 4 const router = new Router({ scrollBehavior(to, from, savedPosition) { // scroll to id `can~contain-special\u0026gt;characters` + 200px  return { el: \u0026#39;#can~contain-special\u0026gt;characters\u0026#39; // top relative offset  top: 200 // instead of `offset: { y: 200 }`  } } }) 更强大的 Devtools 多亏了新的Vue Devtools，Vue Router 能够和浏览器进行以下更高级的整合。\n 时间轴记录路由变化：   Timeline  完整 route 目录，能够帮助你轻松进行调试：   Routes directory   更好的路由守卫 beforeEach // BAD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) // 如果用户未能验证身份，则 `next` 会被调用两次  next() }) // GOOD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) else next() }) 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。 和next说拜拜，现在确认跳转不需要再手动执行这个函数了，而是根据你的返回值来决定行为。同样支持异步返回 Promise。\n现在的路由守卫 API 更加友好且合理了，可以完美利用 async await 做异步处理，比如这样：\nrouter.beforeEach(async (to, from) =\u0026gt; { // canUserAccess() returns `true` or `false`  return await canUserAccess(to) }) 路由独享的守卫 现在beforeEnter支持传入函数数组，便于复用，例如跳转到某个路由后自动去除所有query和hash\n// vue-router 3 const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, beforeEnter: (to, from, next) =\u0026gt; { // ...  } } ] }) // vue-router 4 function removeQueryParams(to) { if (Object.keys(to.query).length) return { path: to.path, query: {}, hash: to.hash } } function removeHash(to) { if (to.hash) return { path: to.path, query: to.query, hash: \u0026#39;\u0026#39; } } const routes = [ { path: \u0026#39;/users/:id\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams, removeHash], }, { path: \u0026#39;/about\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams], }, ] 迁移成本低 Vue Router 4 主要致力于于在改善现有 Router 的同时保持非常相似的 API，如果你已经很上手旧版的 Vue Router 了，那你的迁移会做的很顺利，可以查看文档中的完整迁移指南。\n展望未来 在过去的几个月中，Vue Router 一直稳定而且好用，现在它可以做些更好玩的事儿了：\n 使用现有工具（Vetur，Vite，Devtools 等）得到更好的开发体验。 与 Suspense 等现代功能更好地集成。 RFCs 和社区共同探讨出更好用的 API。 开发更轻型的版本。  Breaking Changes(partial) New history option to replace mode The mode: \u0026lsquo;history\u0026rsquo; option has been replaced with a more flexible one named history. Depending on which mode you were using, you will have to replace it with the appropriate function:\n \u0026ldquo;history\u0026rdquo;: createWebHistory() \u0026ldquo;hash\u0026rdquo;: createWebHashHistory() \u0026ldquo;abstract\u0026rdquo;: createMemoryHistory()  Here is a full snippet:\nimport { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; // there is also createWebHashHistory and createMemoryHistory  createRouter({ history: createWebHistory(\u0026#39;/base-directory/\u0026#39;), routes: [], }) Missing required params on named routes Pushing or resolving a named route without its required params will throw an error:\n// given the following route: const routes = [{ path: \u0026#39;/users/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: UserDetails }] // Missing the `id` param will fail router.push({ name: \u0026#39;user\u0026#39; }) router.resolve({ name: \u0026#39;user\u0026#39; }) 参考资料：\nVue Router 3.0 文档 Vue Router 4.0 release log\nVue Router 4.0 doc\nVue Router Migration Vue Router4 dynamic routing Routes' Matching Syntax router-scroll-position Path Ranker vue-router-next GitHub repo\n","date":"2020-12-13T19:23:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/vue-router-4.0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/vue-router-4.0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B/","title":"Vue Router 4.0特性简介"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/","title":""}]