[{"content":"参考：https://pomb.us/build-your-own-react/ 基于React 16.8实现，因而可以使用hook，不再书写使用过去的class相关的代码。\n实现React的基本思路如下： Step I: The createElement Function 第一步：创建节点 Step II: The render Function 第二步：渲染 Step III: Concurrent Mode 第三步：concurrent模式 Step IV: Fibers 第四步：Fiber“纤维” Step V: Render and Commit Phases 第五步： 渲染和Commit阶段 Step VI: Reconciliation 第六步：调和 Step VII: Function Components 第七步：函数组件 Step VIII: Hooks 第八步：Hooks\n第0步：回顾 下面是最简单的几行React代码：\nconst element = \u0026lt;h1 title=\u0026#34;foo\u0026#34;\u0026gt;Hello\u0026lt;/h1\u0026gt; const container = document.getElementById(\u0026#34;root\u0026#34;) ReactDOM.render(element, container) // 把element插入到页面的DOM节点container中 第一行代码替换成vanilla（香草？）JS代码，变化如下：\n// JSX 通过Babel编译成JS // 一般转换过程都很简单：调用createElement把tag内的代码替换掉，传入tag名，属性和子节点作为参数 const element = \u0026lt;h1 title=\u0026#34;foo\u0026#34;\u0026gt;Hello\u0026lt;/h1\u0026gt;  // ========transformation========= const element = React.createElement( \u0026#34;h1\u0026#34;, { title: \u0026#34;foo\u0026#34; }, \u0026#34;Hello\u0026#34; ) // React.createElement 根据入参返回一个对象。中间还有一些校验。 // 所以我们可以直接将函数调用替换为函数最终的输出。 // 这就是React中一个element object，包含type和props两个字段（目前我们只关注这两个属性） const element = { // type是一个字符串，表明我们想要创建的DOM节点的类型，和document.createElement方法中的tagName是一样的。type也可以是一个函数，这个留到第7步再作讲解。  type: \u0026#39;h1\u0026#39;, // props是一个对象，它包含所有JSX属性的键值对。它还包含一个特殊的属性children。  props: { title: \u0026#39;foo\u0026#39;, // children在这里是一个字符串，但是它通常是一个数组，包含多个element。这也是elements也是树的原因。  children: \u0026#39;Hello\u0026#39; } }; 然后还有第3行代码，这是React渲染/修改DOM的地方，现在由我们自己来实现这个更新。\n首先我们根据React element的type去创建一个DOM节点node，在这个例子中是h1。 然后我们将element所有的属性prop添加到这个node上，这里暂时只有title。\nconst node = document.createElement(element.type); node[\u0026#39;title\u0026#39;] = element.props.title; 然后我们为children创建DOM节点。这里只有一个文本作为child，所以我们创建为它创建一个text node。\nconst text = document.createTextNode(\u0026#39;\u0026#39;); // 用textNode而不是设置innerText会允许我们稍后用相同的方式来处理所有的elements。 // 同样要注意我们就像对h1设置title属性一样，对textNode设置nodeValue，就像这个字符串拥有自己的props: {nodeValue: \u0026#34;hello\u0026#34;}似的。 text[\u0026#39;nodeValue\u0026#39;] = element.props.children; 最后，把text添加到h1 node中，把node添加到container中。\nnode.appendChild(text); container.appendChild(node); 现在，我们实现了之前依靠React JSX和React.render才实现的功能。\nconst element = { type: \u0026#39;h1\u0026#39;, props: { title: \u0026#39;foo\u0026#39;, children: \u0026#39;Hello\u0026#39; } }; const container = document.getElementById(\u0026#34;root\u0026#34;); const node = document.createElement(element.type); node[\u0026#39;title\u0026#39;] = element.props.title; const text = document.createTextNode(\u0026#39;\u0026#39;); text[\u0026#39;nodeValue\u0026#39;] = element.props.children; node.appendChild(text); container.appendChild(node); 第1步 createElement函数 现在，让我们用另一个app重新开始。\nconst element = ( \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;a\u0026gt;bar\u0026lt;/a\u0026gt; \u0026lt;b /\u0026gt; \u0026lt;/div\u0026gt; ) const container = document.getElementById(\u0026#34;root\u0026#34;) ReactDOM.render(element, container) 这次我们会用我们自己版本的React去替换原来的React。 我们从实现createElement函数开始。让我们将JSX转换为JS，从而看见createElement的调用。\nconst element = React.createElement( \u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }, [ React.createElement(\u0026#39;a\u0026#39;, null, \u0026#39;bar\u0026#39;), React.createElement(\u0026#39;b\u0026#39;) ] ) 正如我们上一步看到的那样，一个element是一个包含type和props两个属性的对象。所以我们的函数只需要执行创建对象的工作。 现在我们来实现createElement函数。\n//我们对props使用...扩展符号，对children使用剩余符号，这样children的值将一定是数组。 function createElement(type, props, ...children) { return { type, props: { ...props, children } } } const element = createElement(\u0026#39;div\u0026#39;); // { type: \u0026#39;div\u0026#39;, props: { children: [] } } const a = createElement(\u0026#39;div\u0026#39;, null, a); // { type: \u0026#39;div\u0026#39;, props: { children: [a] } } const c = createElement(\u0026#39;div\u0026#39;, null, a, b); // { type: \u0026#39;div\u0026#39;, props: { children: [a, b] } } children数组也可以包含基本类型，比如字符串或数字。所以我们会将非对象的类型包裹在一个element中，并创建一个特殊type，名叫TEXT_ELEMENT。\nfunction createElement(type, props, ...children) { return { type, props: { ...props, children: children.map(child =\u0026gt; { typeof child === \u0026#39;object\u0026#39; ? child : createTextElement(child) }) } } } function createTextElement(text) { return { type: \u0026#39;TEXT_ELEMENT\u0026#39;, props: { nodeValue: text, children: [] } } } 注意，React源码并没有像这样包裹基本类型值或在没有children时创建空数组，但我们这样做可以简化代码。对于我们的库，我们更喜欢简单的代码，而非高性能的代码。\n上文我们还在用React.createElement。现在，我们用Didact来替换React，表明为我们自己实现的库。目前，让它包含上面刚刚实现的createElement方法。\nconst Didact = { createElement } const element = Didact.createElement( \u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }, [ Didact.createElement(\u0026#39;a\u0026#39;, null, \u0026#39;bar\u0026#39;), Didact.createElement(\u0026#39;b\u0026#39;) ] ) 上面是编译后的JS代码。在这之前，我们还是得用JSX。那么我们怎么让babel知道要编译成Didact.createElement而不是React的createElement呢？ 像这样注释，当babel编译JSX时它就会用我们定义的函数。\n/** @jsx Didact.createElement */ const element = ( \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;a\u0026gt;bar\u0026lt;/a\u0026gt; \u0026lt;b /\u0026gt; \u0026lt;/div\u0026gt; ) 第2步 render函数 创建好了element，现在我们要实现自己的render函数，将一个object转换为DOM节点并添加到container中：\nReactDOM.render(element, container) 现在，我们只关注添加节点到DOM中。我们稍后会再处理update和delete操作。\nconst Didact = { createElement, render } function render(element, container) { // TODO create dom nodes } // ...jsx // const container = document.getElementById(\u0026#39;root\u0026#39;) Didact.render(element, container); 我们从根据type创建一个DOM node，然后将该node添加到container中开始：\nfunction render(element, container) { // 在这里也要对text节点特殊处理，如果type为之前设定的TEXT_ELEMENT，则需要调用createTextNode方法  const dom = element.type === \u0026#39;TEXT_ELEMENT\u0026#39; ? document.createTextNode(\u0026#39;\u0026#39;) : document.createElement(element.type); // 还记得每个element的属性吗？除了children，其余的属性都要绑定到对应的DOM node上  const isProperty = key =\u0026gt; key !== \u0026#39;children\u0026#39;; Object.keys(element.props).filter(isProperty).forEach(name =\u0026gt; { dom[name] = element.props[name]; }); // 然后对element的每个子节点做递归操作，生成DOM node并添加到该element对应的DOM node中，形成真正的DOM树  element.children.forEach(child =\u0026gt; { render(child, dom); }); container.appendChild(dom); } 完成。现在我们有了一个可以将JSX转译为DOM的库了。https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js\n第3步 concurrent模式 在添加更多代码前，我们需要做个重构。上面的forEach render递归调用存在一个问题，就是当element树太大时，它可能会阻断主线程太久。 而且，如果浏览器需要执行高优先级的工作，例如提交用户输入，或者保障动画流畅播放，那么浏览器就要等到它完成渲染。\n所以我们要将渲染工作拆分成小的单元，每执行完一个，浏览器发现还有别的是事情要做的话就会中断渲染。\n// 我们用requestIdleCallback来建立一个循环。你可以把它看作setTimeout，但是不是由我们去告诉它什么时候运行，而是由浏览器在主线程空闲是去执行callback。  // React不再使用requestIdleCallback。现在它使用scheduler package。但是在这个用例中它们的概念是类似的。 let nextUnitOfWork = null; // 入参deadline可以用来检查在浏览器需要重新take control之前我们还有多少时间去执行渲染 function workLoop(deadline) { let shouldYield = false; // 如果还有任务 \u0026amp;\u0026amp; 当前帧还有空闲  while (nextUnitOfWork \u0026amp;\u0026amp; !shouldYield) { nextUnitOfWork = performUnitOfWork(nextUnitOfWork); shouldYield = deadline.timeRemaing() \u0026lt; 1 } requestIdleCallback(workLoop) // 等待下一帧 } requestIdleCallback(workLoop) // 启动时间切片 function performUnitOfWork(nextUnitOfWork) { // TODO } As of截至2019年11月, Concurrent Mode还没有发布稳定版本。循环的稳定版本更像是下面这样：\nwhile (nextUnitOfWork) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) } 要开始使用这个循环，我们需要设置任务的第一个单元，然后编写performUnitOfWork方法，这个方法不仅执行当前的任务，还会返回下一个单元的任务。\n第4步 fiber树 我们需要一种形如纤维树的数据结构来组织单元任务。每个React element，都会有一个对应的fiber，它们是一一对应的关系。\n举个例子： 假设我们要渲染一个像这样的element树结构到DOM中：\nDidact.render( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;p /\u0026gt; \u0026lt;a /\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h2 /\u0026gt; \u0026lt;/div\u0026gt;, container )   fiber1.png  在render函数中我们会创建根fiber，然后将其设为nextUnitOfWork。其余的工作会在performUnitOfWork中进行，在该函数中我们会对每个fiber做以下三件事：\n add the element to the DOM 将element添加到DOM create the fibers for the element’s children 为这个fiber的children创建它们自己的fiber select the next unit of work 选择下一个单元任务  这样类似纤维的数据结构的一个好处就是由于每个fiber都和自己的第一个子节点、相邻节点和父节点有一个连接，可以很容易确认下一个单元任务，即下一个要进行渲染的element。\n  当我们完成了对一个fiber的任务的执行，如果这个fiber有子节点，那么这个子节点就会成为下一个单元任务。对于本例，当我们完成div这个fiber的工作，下一个单元任务将会是h1这个fiber。\n  如果当前的fiber没有子节点，我们会让它的相邻节点成为下个单元任务。例如，p这个fiber没有子节点，所以我们会在完成渲染它之后移动到a这个fiber。   fiber3.png \n  而如果这个fiber没有子节点也没有相邻节点，我们会去找它的“叔叔”：父节点的相邻节点，例如本例中的h2。   fiber4.png  另外，如果父节点没有相邻节点，我们继续向上沿着父节点寻找，直到找到了有相邻节点的父节点，或者是到达根节点。如果我们到达了根节点，则说明我们已经完成了对这次render的所有任务。\n  现在让我们用代码进行实现吧！\n首先将原先render函数里的创建DOM的代码抽离出来：\nfunction render(element, container) { // 创建DOM  const dom = element.type === \u0026#39;TEXT_ELEMENT\u0026#39; ? document.createTextNode(\u0026#39;\u0026#39;) : document.createElement(element.type); const isProperty = key =\u0026gt; key !== \u0026#39;children\u0026#39;; Object.keys(element.props).filter(isProperty).forEach(name =\u0026gt; { dom[name] = element.props[name]; }); // 对子节点递归调用  element.children.forEach(child =\u0026gt; { render(child, dom); }); // 添加到容器中  container.appendChild(dom); } 将创建DOM的部分抽离出来形成一个新的方法createDOM，入参为fiber，即element。稍后我们会用到这个方法。\nfunction createDom(fiber) { const dom = fiber.type === \u0026#39;TEXT_ELEMENT\u0026#39; ? document.createTextNode(\u0026#39;\u0026#39;) : document.createElement(fiber.type); const isProperty = key =\u0026gt; key !== \u0026#39;children\u0026#39;; Object.keys(fiber.props) .filter(isProperty) .forEach(name =\u0026gt; { dom[name] = fiber.props[name]; }); return dom; } 然后，在render方法中，我们把fiber树的根节点作为nextUnitOfWork:\nfunction render (element, container) { // 最初最初的节点为container，一个已有的DOM节点，放在nextUnitOfWork，即fiber的dom属性中  // nextUnitOfWork对象还有type属性，最初节点没有自身属性，只有children，包含一个我们创建好的element  let nextUnitOfWork = { dom: container, props: { children: [element] } } } let nextUnitOfWork = null 然后，当浏览器ready后，它会调用我们上面所写的workLoop方法，我们就会开始从root进行渲染工作。 现在我们来实现performUnitOfWork方法。\nfunction performUnitOfWork(fiber) { // 1. 首先，我们创建一个新的DOM node，并将其添加到DOM中  // 我们用fiber.dom属性去追踪DOM节点信息  if (!fiber.dom) { fiber.dom = createDom(fiber); } if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom); } // 2. 然后我们为每一个子节点创建一个新的fiber  const elements = fiber.props.children; let prevSibling = null; for (let i = 0; index \u0026lt; elements.length; i++) { const element = elements[i]; const newFiber = { type: element.type, props: element.props, dom: null, parent: fiber } // 建立fiber连接，根据索引是否为0设置为当前fiber的child或是上一个子节点的相邻节点  if (i === 0) { fiber.child = newFiber; } else { prevSibling.sibling = newFiber; } prevSibling = newFiber; } // 3. 最后我们搜索并确立下一个单元任务。我们先试试子节点child，没有child的话就相邻节点=》父节点的相邻节点这样循环搜索。  if (fiber.child) { return fiber.child; } let nextFiber = fiber; while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling; } nextFiber = nextFiber.parent; } } 以上就是performUnitOfWork方法的实现。\n第5步：Render和Commit阶段 现在我们还面临一个问题。每次我们对一个element进行操作时，都会将一个新的node节点那添加到DOM中，但是记住，浏览器可以在我们完成渲染整个树结构之前中断渲染工作去执行更高优先级的任务，在那种情况下，用户会看见一个不完整的UI。我们不希望那种情况发生。所以我们需要将修改DOM的代码片段抽离出来。\nfunction performUnitOfWork(fiber) { // ...  // 修改DOM，需要提出去  if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom); } // ... } 反之，我们需要持续跟踪fiber树的根。我们称它为work in progress root或wipRoot。在render方法中重新命名：\nfunction render (element, container) { wipRoot = { dom: container, props: { children: [element] } } nextUnitOfWork = wipRoot; } let nextUnitOfWork = null; let wipRoot = null; 然后，当我们完成了所有的渲染工作（不存在下一个单元任务时）我们将整个fiber树提交到DOM中（每个fiber都已经带有了它对应要渲染到document上的附带属性的DOM节点）。\nfunction commitRoot() { // TODO add nodes to dom } function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, } nextUnitOfWork = wipRoot } ​ let nextUnitOfWork = null let wipRoot = null ​ function workLoop(deadline) { let shouldYield = false while (nextUnitOfWork \u0026amp;\u0026amp; !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() \u0026lt; 1 } ​ // 没有下一个单元任务，说明fiber树构建完成，整体提交到DOM中  if (!nextUnitOfWork \u0026amp;\u0026amp; wipRoot) { commitRoot() } requestIdleCallback(workLoop) } ​ requestIdleCallback(workLoop) 我们在commitRoot方法中实现提交功能。在commitWork里递归添加所有node到DOM树中。\nfunction commitRoot() { // 这里child就是实际要添加到已有DOM容器节点的根element  commitWork(wipRoot.child); wipRoot = null; } function commitWork(fiber) { if (!fiber) { return; } const fiberParentDom = fiber.parent.dom; fiberParentDom.appendChild(fiber.dom); commitWork(fiber.child); commitWork(fiber.sibling); } 第6步：Reconciliation 调和 （DIFF算法） 目前为止我们只是完成了添加节点到DOM的实现，那么更新和删除节点呢？ 这就是我们现在要做的，将我们在render方法中接收到的elements和上一个我们提交到DOM的fiber树进行对比。\n所以我们需要将上一个完成渲染的fiber树保存到一个引用当中，我们叫它currentRoot。 同时，对每一个fiber添加一个alternate属性。这个属性是对旧fiber的链接，即我们在上一个从commit阶段提交到DOM的fiber。\nlet nextUnitOfWork = null; let currentRoot = null; let wipRoot = null; function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, // 添加alternate属性存储上一次渲染的对应的fiber  alternate: currentRoot } nextUnitOfWork = wipRoot } function commitRoot() { // 这里child就是实际要添加到已有DOM容器节点的根element  commitWork(wipRoot.child); currentRoot = wipRoot; wipRoot = null; } function commitWork(fiber) { if (!fiber) { return; } const fiberParentDom = fiber.parent.dom; fiberParentDom.appendChild(fiber.dom); commitWork(fiber.child); commitWork(fiber.sibling); } 现在让我们把performUnitOfWork中创建新fiber的代码抽离出来：\nfunction performUnitOfWork(fiber) { if (!fiber.dom) { fiber.dom = createDom(fiber) } ​ const elements = fiber.props.children let index = 0 let prevSibling = null ​ while (index \u0026lt; elements.length) { const element = elements[index] ​ const newFiber = { type: element.type, props: element.props, parent: fiber, dom: null, } ​ if (index === 0) { fiber.child = newFiber } else { prevSibling.sibling = newFiber } prevSibling = newFiber index++ } ​ if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } } function performUnitOfWork(fiber) { if (!fiber.dom) { fiber.dom = createDom(fiber) } const elements = fiber.props.children // 当前的fiber和它的子节点们，调用构建fiber树结构函数reconcileChildren  reconcileChildren(fiber, elements) if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } } function reconcileChildren(wipFiber, elements) { let index = 0 let prevSibling = null ​ while (index \u0026lt; elements.length) { const element = elements[index] ​ const newFiber = { type: element.type, props: element.props, parent: wipFiber, dom: null, } if (index === 0) { wipFiber.child = newFiber } else { prevSibling.sibling = newFiber } prevSibling = newFiber index++ } } 继续修改reconcileChildren，这里我们会将旧的fibers和新的elements进行调和。 We iterate at the same time over the children of the old fiber (wipFiber.alternate) and the array of elements we want to reconcile.\n如果我们忽略所有在一个数组和一个链表上同时遍历的样板代码（boilerplate）。我们会得到这里面最重要的两个变量：oldFiber和element。\n我们需要对比这两个变量，即这次要渲染的fiber的子fiber和上次的子fiber，来确认我们时候要将什么变化应用到DOM上。\n我们用type来比较它们:\n 如果旧fiber和新element的type相同，我们可以让DOM node留在那里，只更新一些新的属性。 如果type不同，有一个新的element，这意味着我们需要创建一个新的node 如果type不同，有一个旧的fiber，我们需要移除掉旧的DOM node  这里React也使用keys这个属性，这让调和效果更好。例如，它会发现子节点们在element数组中的排列顺序的改变。\nfunction reconcileChildren(wipFiber, elements) { let index = 0 // 上次渲染到DOM的对应节点的子fiber  let oldFiber = wipFiber.alternate \u0026amp;\u0026amp; wipFiber.alternate.child; let prevSibling = null ​ // 循环条件增加oldFiber不为空  while (index \u0026lt; elements.length \u0026amp;\u0026amp; oldFiber !== null) { // element是现在要渲染到DOM上的节点的子fiber  const element = elements[index] ​ let newFiber = null; // 将旧fiber和现element进行比较  const sameType = element \u0026amp;\u0026amp; oldFiber \u0026amp;\u0026amp; element.type === oldFiber.type; // 更新节点  if (sameType) { // 创建一个新的fiber，维持旧fiber的dom，设置新element的props  // 同时添加一个新属性effectTag，这个属性会在稍后的commit阶段用到  newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, parent: wipFiber, effectTag: \u0026#39;UPDATE\u0026#39;, alternate: oldFiber } // 添加新节点  } else if (!sameType \u0026amp;\u0026amp; element) { // 对于element需要一个新的DOM节点的case，我们对新fiber添加一个值为PLACEMENT的tag  newFiber = { type: element.type, props: element.props, dom: null, // 后面会用fiber来调用createDom，这里只是将element转为fiber  parent: wipFiber, effectTag: \u0026#39;PLACEMENT\u0026#39;, alternate: null } // 删除旧节点  } else if (!sameType \u0026amp;\u0026amp; oldFiber) { // 对于要删除node的case，我们没有新的fiber，所以对旧fiber添加一个DELETION的tag。  oldFiber.effectTag = \u0026#39;DELETION\u0026#39;; // 但是，由于我们是从wipRoot提交fiber树到DOM中的，这个fiber树结构已经不再包含旧的fiber了  // 所以我们需要一个数组deletions来记录我们要移除的node节点  deletions.push(oldFiber); } if (index === 0) { wipFiber.child = newFiber } else { prevSibling.sibling = newFiber } prevSibling = newFiber index++ } } function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, alternate: currentRoot, } // 每次开始渲染时，初始化要移除的node节点为空数组  deletions = [] nextUnitOfWork = wipRoot } let nextUnitOfWork = null let currentRoot = null let wipRoot = null let deletions = null // 然后，当我们将变更提交到DOM时，我们也对那个数组中的fiber调用commitWork。 function commitRoot() { deletions.forEach(commitWork) commitWork(wipRoot.child) currentRoot = wipRoot wipRoot = null } ​ 接下来要修改commitWork方法来处理上面增加的effectTag：\nfunction commitWork(fiber) { if (!fiber) { return; } const domParent = fiber.parent.dom; // 如果fiber有PLACEMENT这个effect tag我们就和之前一样，添加fiber的dom节点到它的parent的dom节点中去。  if (fiber.effectTag === \u0026#39;PLACEMENT\u0026#39; \u0026amp;\u0026amp; fiber.dom !== null) { domParent.appendChild(fiber.dom) // 如果是UPDATE，那么就将新fiber的props更新到已有的dom节点中  // 并且替换掉之前已有的props的值  } else if (fiber.effectTag === \u0026#39;UPDATE\u0026#39; \u0026amp;\u0026amp; fiber.dom !== null) { updateDom( fiber.dom, fiber.alternate.props, fiber.props ) // 如果是DELETION，我们就做相反操作，移除子节点  } else if (fiber.effectTag === \u0026#39;DELETION\u0026#39;) { domParent.removeChild(fiber.dom) } commitWork(fiber.child); commitWork(fiber.sibling); } 接下来要实现updateDom方法。我们将旧fiber和新fiber的props进行比较，移除那些不再有的props，并且设置那些新的props或者是变化了的值的props。\n// 是新值或者是全新的prop const isNew = (prev, next) =\u0026gt; key =\u0026gt; prev[key] !== next[key] const isGone = (prev, next) =\u0026gt; key =\u0026gt; !(key in next); // 注意，还有一种特殊prop我们可能需要更新的是event listener。所以如果以on为开头的prop我们需要对它们进行特殊处理。 const isEvent = key =\u0026gt; key.startsWith(\u0026#39;on\u0026#39;) const isProperty = key =\u0026gt; key !== \u0026#39;children\u0026#39; \u0026amp;\u0026amp; !isEvent(key); function updateDom(dom, prevProps, nextProps) { // 如果事件监听器变了，或者不再有，那么我们需要先移除掉旧的。  Object.keys(prevProps) .filter(isEvent) .filter( key =\u0026gt; !(key in nextProps) || isNew(prevProps, nextProps)(key) ) .forEach(name =\u0026gt; { const eventType = name.toLowerCase().substring(2); dom.removeEventListener(eventType, prevProps[name]); }) // 移除旧的property  Object.keys(prevProps) .filter(isProperty) .filter(isGone(prevProps, nextProps)) .forEach(name =\u0026gt; { dom[name] = \u0026#39;\u0026#39;; }) // 设置新的或值变了的property  Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach(name =\u0026gt; { dom[name] = nextProps[name]; }) // 然后添加新fiber的事件监听器  Object.keys(nextProps) .filter(isEvent) .filter(isNew(prevProps, nextProps)) .forEach(name =\u0026gt; { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, nextProps[name]); }) } 至此，我们完成了调和工作啦！ 尝试地址：https://codesandbox.io/s/didact-6-96533\n第7步：函数组件 我们下一步要做的就是添加对函数式组件的支持。 首先让我们来修改一下例子。我们会用这个简单的返回一个h1元素的函数组件。\n// 普通写法，没有带自定义组件 const element = ( \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;a\u0026gt;bar\u0026lt;/a\u0026gt; \u0026lt;b /\u0026gt; \u0026lt;/div\u0026gt; ) // 函数式组件写法 /** @jsx Didact.createElement */ function App(props) { return \u0026lt;h1\u0026gt;Hi {props.name}\u0026lt;/h1\u0026gt; } const element = \u0026lt;App name=\u0026#34;foo\u0026#34; /\u0026gt; const container = document.getElementById(\u0026#34;root\u0026#34;) Didact.render(element, container) 我们将这段jsx代码转译成js，就会变成：\nfunction App(props) { return Didact.createElement( \u0026#34;h1\u0026#34;, null, \u0026#34;Hi \u0026#34;, props.name ) } const element = Didact.createElement(App, { name: \u0026#34;foo\u0026#34;, }) 函数式组件在两个方面有所区别：\n 源自函数组件的fiber没有DOM节点 子节点们是在运行函数时得来的，而不是直接从props中得来  因此在performUnitOfWork方法中，我们重构创建dom和获取子节点的代码段，改为检查fiber的type是否是function，并根据判断结果去执行不同的update方法。\nfunction performUnitOfWork(fiber) { // if (!fiber.dom) {  // fiber.dom = createDom(fiber)  // }  // const elements = fiber.props.children  // // 当前的fiber和它的子节点们，调用构建fiber树结构函数reconcileChildren  // reconcileChildren(fiber, elements)  const isFunctionComponent = fiber.type instanceof Function if (isFunctionComponent) { updateFunctionComponent(fiber) } else { updateHostComponent(fiber) } // 遍历fiber链表  if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } } ​ // 在updateHostComponent中我们会和之前做一样的事情 function updateHostComponent(fiber) { if (!fiber.dom) { fiber.dom = createDom(fiber) } const elements = fiber.props.children // 当前的fiber和它的子节点们，调用构建fiber树结构函数reconcileChildren  reconcileChildren(fiber, elements) } 在updateFunctionComponent函数中我们执行获取组件本身（函数）来获取其子节点。 对于我们的例子，在这里fiber.type是App这个方法，而当我们去执行它，它会返回h1 这个element。 然后，一旦我们获取到了子节点，reconciliation以一样的方式工作，我们不需要在那里修改任何东西。\nfunction updateFunctionComponent(fiber) { const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children) } 现在我们需要修改commitWork这个方法。有了不带DOM节点的fiber，所以我们需要修改两个地方。 首先，要找到父fiber的DOM节点我们需要沿着fiber树向上走，知道找到一个拥有DOM node的fiber。\n// const domParent = fiber.parent.dom;  let domParentFiber = fiber.parent while (!domParentFiber.dom) { domParentFiber = domParentFiber.parent } const domParent = domParentFiber.dom 另外，删除一个节点是也是要沿着fiber树向下寻找child，到找到了有DOM node的fiber。\nelse if (fiber.effectTag === \u0026#39;DELETION\u0026#39;) { commitDeletion(fiber, domParent) } function commitDeletion(fiber, domParent) { if (fiber.dom) { domParent.removeChild(fiber); } else { commitDeletion(fiber.child, domParent); } } /** @jsx Didact.createElement */ function App(props) { return \u0026lt;h1\u0026gt;Hi {props.name}\u0026lt;/h1\u0026gt; } const element = \u0026lt;App name=\u0026#34;foo\u0026#34; /\u0026gt; const container = document.getElementById(\u0026#34;root\u0026#34;) Didact.render(element, container) 第8步 Hooks 最后一步。既然我们有了函数组件，那么让我们也加下state。 让我们将例子更改为经典的counter组件。每次我们点击它，它都会将state加1。请注意我们在使用Didact.useState来获取和更新counter的值。\nconst Didact = { createElement, render, useState, } /** @jsx Didact.createElement */ function Counter() { // Here is where we call the Counter function from the example. And inside that function we call useState.  const [state, setState] = Didact.useState(1) return ( \u0026lt;h1 onClick={() =\u0026gt; setState(c =\u0026gt; c + 1)}\u0026gt; Count: {state} \u0026lt;/h1\u0026gt; ) } const element = \u0026lt;Counter /\u0026gt; const container = document.getElementById(\u0026#34;root\u0026#34;) Didact.render(element, container) function useState(initial) { // TODO } 在调用函数组件之前，我们需要初始化一些全局变量，这样我们就能在useState方法中使用它们。 首先我们设置工作中的fiber。 我们同样添加一个hooks数组到fiber中，来支持在同一个组件中多次调用useState。并且我们保持跟踪现在的hook索引。\nlet wipFiber = null; let hookIndex = null; function updateFunctionComponent(fiber) { // 在更新函数组件的方法中初始化hooks  wipFiber = fiber; hookIndex = 0; wipFiber.hooks = []; const children = [fiber.type(fiber.props)]; reconcileChildren(fiber, children); } 当函数组件调用useState方法时，我们去检查是否有一个旧的hook。我们用hook索引去到这个fiber的alternate中检查。\n如果我们有一个旧的hook，我们将旧hook中的state复制到新的hook中；如果我们没有，那么就初始化这个state。\n然后我们添加这个新的hook到fiber中，给hook索引加1，然后返回这个state。\nfunction useState(initial) { const oldHook = wipFiber \u0026amp;\u0026amp; wipFiber.alternate.hooks \u0026amp;\u0026amp; wipFiber.alternate.hooks[hookIndex]; const hook = { state: oldHook ? oldHook.state : initial } wipFiber.hooks.push(hook); hookIndex++; return [hook.state]; } useState还应该返回一个更新state的函数，所以我们定义一个setState方法，这个方法接收一个action（对于Counter例子而言，这个action就是一个让state加1的函数）。 我们将那个action添加到hook的queue队列中。 然后我们做一些和在render函数中所做的类似的事情：设置一个新的工作中root，作为下一个单元任务，这样work loop就能开始一个新的render阶段。\n注意我们还没有执行action。\n我们在下一次render组件时执行。从旧的hook的queue中获取所有actions，然后将它们逐一运用到新的hook state中，因此当我们最终返回state时它是更新过的。\nfunction useState(initial) { const oldHook = wipFiber \u0026amp;\u0026amp; wipFiber.alternate.hooks \u0026amp;\u0026amp; wipFiber.alternate.hooks[hookIndex]; const hook = { state: oldHook ? oldHook.state : initial, queue: [], // queue存放setState的入参，表示一个修改state的函数  } // 执行actions  const actions = oldHook ? oldHook.queue : []; actions.forEach(action =\u0026gt; { hook.state = action(hook.state); }) const setState = action =\u0026gt; { hook.queue.push(action); // 浏览器空闲时进行重新performUnitOfWork  wipRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } nextUnitOfWork = wipRoot; deletions = []; } wipFiber.hooks.push(hook); hookIndex++; // hooks一定要有顺序  return [hook.state, setState]; } 以上就是我们自行实现的版本的React啦！ 在线版本：https://codesandbox.io/s/didact-8-21ost\n后记 Besides helping you understand how React works, one of the goals of this post is to make it easier for you to dive deeper in the React codebase. That’s why we used the same variable and function names almost everywhere.\nFor example, if you add a breakpoint in one of your function components in a real React app, the call stack should show you:\n workLoop performUnitOfWork updateFunctionComponent  We didn’t include a lot of React features and optimizations. For example, these are a few things that React does differently:\n In Didact, we are walking the whole tree during the render phase. React instead follows some hints and heuristics to skip entire sub-trees where nothing changed. We are also walking the whole tree in the commit phase. React keeps a linked list with just the fibers that have effects and only visit those fibers. Every time we build a new work in progress tree, we create new objects for each fiber. React recycles the fibers from the previous trees. When Didact receives a new update during the render phase, it throws away the work in progress tree and starts again from the root. React tags each update with an expiration timestamp and uses it to decide which update has a higher priority. And many more…  There are also a few features that you can add easily:\n use an object for the style prop flatten children arrays useEffect hook reconciliation by key  If you add any of these or other features to Didact send a pull request to the GitHub repo, so others can see it. https://github.com/pomber/didact\n","date":"2021-03-30T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/react_hu4014157c127633b5f677ff85eb79e346_173734_120x120_fill_q75_box_smart1.jpeg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0react/","title":"从0开始实现React"},{"content":" 浏览器从输入URL到显示页面中间发生的事情  一文摸透从输入URL到页面渲染的过程\n一言以概之：浏览器主进程 -\u0026gt; 网络进程 -\u0026gt; 渲染进程 -\u0026gt; GPU进程 -\u0026gt; 浏览器主进程\n HTTP协议相关、网络攻击 状态码、首部、请求方法、状态管理、身份认证、身份认证、长连接与短连接、代理网关与隧道、HTTP缓存、内容协商机制、断点续传和多线程下载、HTTPS、WebSocket、SPDY、HTTP 2.0、HTTP 3.0、Web安全 详解HTTP协议\nURI包含URL、URN或同时具备locators和name特性的东西。URL给出了访问机制http ftp telnet等。URI唯一标识了身份。\n  请求首部：\n Accept Accet-Charset Accept-Encoding Accept-Language If-Match === ETag 200 If-Modified-Since \u0026lt; Last Modified 200 === Last Modified 304 If-None-Match !== ETag 200 If-Range === ETag/date 206 !== ETag/date 200 配合Range(Etag/date)使用 Referer: 告诉服务器从URI从哪个页面发起  响应首部：\n Age 缓存在源服务器存在多久了 ETag 资源实体标识 Location 3xx 重定向用  通用首部：\n Cache-Control Connection Date     浏览器从输入URL到显示页面中间发生的事情     浏览器从输入URL到显示页面中间发生的事情     浏览器从输入URL到显示页面中间发生的事情     浏览器从输入URL到显示页面中间发生的事情    vue 和 react 设计思路 发展历程 vue1 react15 diff平级 vue2 react16 fiber vue3 \u0026amp; react17\nvue options API 缺点 要新增data，新增method，computed，watch，可维护性越来越差，反复横跳 mixin巨大的坑：命名冲突 this.xx 是一个黑盒 难测试 难推导\nvue3 渐进式更新 ref api composition API 缺点：难看 return。。 setup。。 优点：\n 没有了options 可以做tree-shaking 代码build的时候就会删掉vue3里computed的代码 方便组合，逻辑都是函数，组合优于继承。data和方法可以写在一起了 组件可以任意拆分 到别的文件中，重名的话import的时候改名就可以了 数据流清晰 对Vue.js进行了完全Typescript重构，让Vue.js源码易于阅读、开发和维护；  重写了虚拟Dom的实现，对编译模板进行优化、组件初始化更高效， 性能上有较大的提升；Vue.js2对象式组件存在一些问题：难以复用逻辑代码、难以拆分超大型组件、代码无法被压缩和优化、数据类型难以推倒等问题；而CompositionAPI 则是基于函数理念，去解决上述问题，使用函数可以将统一逻辑的组件代码收拢一起达到复用，也更有利于构建时的tree-shaking检测，这个使用起来有些类似于React的hook；\n以上变化都秉持着VUE的“渐进式框架“ 理念， Vue.js3.0 持续开发兼容旧的版本，即使升级了Vue.js3.0 也可以按照之前的组件开发模式进行开发。 composition和hooks有啥区别？ API相像，底层实现不一样\nreact：class -》 hooks hooks有顺序要求，不能放在if里 每次render都会执行\ncomposition后续靠响应式通知\nvue1 只有响应式，项目大了之后，响应式对象太多，导致卡顿 vue 响应式+vdom\n响应式：数据变了 通知你 通知机制 v-dom 数据变了 你不知道哪里变了，第一次diff才知道变化 怎么配合？\nreact没有响应式，纯v-dom，计算diff v-dom树太大了，diff时间经常超过16.6ms，导致卡顿，怎么办？fiber\nreact单向数据流 更适合大型项目 一切皆组件\ntemplate不够动态，语法限制 v-if v-for 提前定义好的语法 好处：有限制，可遍历，优化空间比较大\njsx 动态化 任意创造div 纯js 使用js语法即可 element3\ntemplate 静态程度高 按需更新 节点的属性 子节点 判断出是否需要diff 自由度不高 编译器可优化点多\njs 组合全县盐政 11 vue3 新概念 block\nvue3 diff最精确 vue-next-template-explorer\n二、虚拟dom 虚拟dom存在的意义：真正操作dom之前进行完整的diff计算，计算结果最小成本操作DOM vue3 diff算法：最长递增子序列 + 双端预判\n虚拟dom vue和react的区别\n 响应式 主动通知 虚拟dom被动计算  vue两个怎么配合？ 根据组件划分，组件之间通过响应式通知，组件内部通过v-dom计算diff\nsvelte没有vdom，直接编译成js vdom 用js的object来描述你的dom节点，跨端\nvue1 dep一来中心 一个节点一个watcher react15 平级对比diff On3 -》 On diff上来就开始 vue2 引入了v-dom使用了snabdom的代码，双端预判，掐头去尾，减少diff，减少循环的次数 每个组件一个watcher\nreact fiber 时间切片\n 任务可以切片 利用空闲时间计算 diff可以中断  树结构 变成 链表 节点之间一次走完 优先级高的任务来了，渲染，动画等，任务结束，继续diff\nvue3 静态标记 静态的不用diff 编译时优化 理念源自prepack 把一些运行时的冗余计算在node层执行完 优化性能 在vue2静态标记的基础上，动态组件内部的静态标记 treeshaking 也是编译时优化\n五、性能优化手段 减少计算 减少操作 compiler vdom 工程化\nthe-super-tiny-compiler\nreact 解析jsx =》 createElement 没有太多的标记 vue3 template compile transform generate\nbabelloader webpack loader\ntry catch async await 可以写一个webpack的loader来做这个转换 加上错误通知机制 上报异常\n 说说 JavaScript 的数据类型 → https://github.com/wengjq/Blog/issues/3  通过 JSON.stringify 的方式实现深拷贝，会有什么问题？ 1、如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；    var test = { name: \u0026#39;a\u0026#39;, date: [new Date(1536627600000), new Date(1540047600000)], }; let b; b = JSON.parse(JSON.stringify(test)) 2、如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；\nconst test = { name: \u0026#39;a\u0026#39;, date: new RegExp(\u0026#39;\\\\w+\u0026#39;), }; // debugger  const copyed = JSON.parse(JSON.stringify(test)); test.name = \u0026#39;test\u0026#39; console.error(\u0026#39;ddd\u0026#39;, test, copyed) 3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；\nconst test = { name: \u0026#39;a\u0026#39;, date: function hehe() { console.log(\u0026#39;fff\u0026#39;) }, }; // debugger  const copyed = JSON.parse(JSON.stringify(test)); test.name = \u0026#39;test\u0026#39; console.error(\u0026#39;ddd\u0026#39;, test, copyed) 4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null 5、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor\nfunction Person(name) { this.name = name; console.log(name) } const liai = new Person(\u0026#39;liai\u0026#39;); const test = { name: \u0026#39;a\u0026#39;, date: liai, }; // debugger  const copyed = JSON.parse(JSON.stringify(test)); test.name = \u0026#39;test\u0026#39; console.error(\u0026#39;ddd\u0026#39;, test, copyed) 6、如果对象中存在循环引用的情况也无法正确实现深拷贝；\n 通过递归的方式实现深拷贝，会有什么问题？ hasOwnProperty和for循环遍历属性 无法拷贝Date、RegExp等原生对象，其属性不可枚举  function deepClone(obj) { if(obj \u0026amp;\u0026amp; typeof obj ===\u0026#39;object\u0026#39; ){ var newObj= Array.isArray(obj) ? []:{}; for (var key in obj) { if(obj.hasOwnProperty(key)){ if(obj[key] \u0026amp;\u0026amp; typeof obj[key]===\u0026#39;object\u0026#39;){ newObj[key]=deepClone(obj[key] ) }else { newObj[key]= obj[key] } } } }else { console.error(\u0026#39;输入参数为空或不为对象\u0026#39;); return \u0026#39;输入参数为空或不为对象\u0026#39; } return newObj } 兼容的做法： 包含Date RegExp Error undefined null\nfunction deepClone(data) { const type = this.judgeType(data); let obj; if (type === \u0026#39;array\u0026#39;) { obj = []; } else if (type === \u0026#39;object\u0026#39;) { obj = {}; } else { // 不再具有下一层次  return data; } if (type === \u0026#39;array\u0026#39;) { // eslint-disable-next-line  for (let i = 0, len = data.length; i \u0026lt; len; i++) { obj.push(this.deepClone(data[i])); } } else if (type === \u0026#39;object\u0026#39;) { // 对原型上的方法也拷贝了....  // eslint-disable-next-line  for (const key in data) { obj[key] = this.deepClone(data[key]); } } return obj; } function judgeType(obj) { // tostring会返回对应不同的标签的构造函数  const toString = Object.prototype.toString; const map = { \u0026#39;[object Boolean]\u0026#39;: \u0026#39;boolean\u0026#39;, \u0026#39;[object Number]\u0026#39;: \u0026#39;number\u0026#39;, \u0026#39;[object String]\u0026#39;: \u0026#39;string\u0026#39;, \u0026#39;[object Function]\u0026#39;: \u0026#39;function\u0026#39;, \u0026#39;[object Array]\u0026#39;: \u0026#39;array\u0026#39;, \u0026#39;[object Date]\u0026#39;: \u0026#39;date\u0026#39;, \u0026#39;[object RegExp]\u0026#39;: \u0026#39;regExp\u0026#39;, \u0026#39;[object Undefined]\u0026#39;: \u0026#39;undefined\u0026#39;, \u0026#39;[object Null]\u0026#39;: \u0026#39;null\u0026#39;, \u0026#39;[object Object]\u0026#39;: \u0026#39;object\u0026#39;, }; if (obj instanceof Element) { return \u0026#39;element\u0026#39;; } return map[toString.call(obj)]; } 用weakMap实现，解决循环引用问题：\nlet map = new WeakMap(); function deepClone (obj) { if (obj instanceof Object) { if (map.has(obj)) { return map.get(obj); } let newObj; // special types  if (obj instanceof Array) { newObj = []; } else if (obj instanceof Date) { newObj = new Date(obj); } else if (obj instanceof Function) { newObj = function () { return obj.apply(this, arguments); } } else if (obj instanceof RegExp) { newObj = new RegExp(obj.source, obj.flags); } else { newObj = {}; } // shallow copy of the current obj and store it in the weakmap  let descriptor = Object.getOwnPropertyDescriptors(obj); let clone = Object.create(Object.getPrototypeOf(obj), descriptor); map.set(obj, clone); // iterate  for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = deepClone(obj[key]); } } return newObj; } else { return obj; } }   基本数据类型和引用数据类型有什么区别？→ 引用数据变量存的是地址 5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。\n  引用数据类型如何进行拷？→ Object.assign 浅拷贝和深拷贝有什么区别？→ JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。\n  目前 JavaScript 的 API 中，哪些是浅拷贝，哪些是深拷贝？→ 浅拷贝：\n  function shallowClone(copyObj) { var obj = {}; for ( var i in copyObj) { obj[i] = copyObj[i]; } return obj; } var x = { a: 1, b: { f: { g: 1 } }, c: [ 1, 2, 3 ] }; var y = shallowClone(x); console.log(y.b.f === x.b.f); // true Object.assign\nvar x = { a: 1, b: { f: { g: 1 } }, c: [ 1, 2, 3 ] }; var y = Object.assign({}, x); console.log(y.b.f === x.b.f); // true 深拷贝： 3.1、Array的slice和concat方法 JSON 如何实现一个深拷贝？→ 见上面代码 github版\nfunction copy (obj,deep) { if ($.isFunction(obj)) { return new Function(\u0026#34;return \u0026#34; + obj.toString())(); } else if (obj === null || typeof obj !== \u0026#34;object\u0026#34;){ return obj; }else { var name, target = $.isArray(obj) ? [] : {}, value; for (name in obj) { value = obj[name]; if (value === obj) { continue; } if (deep) { if ($.isArray(value) || $.isObject(value)) { target[name] = copy(value,deep); } else if ($.isFunction(value)) { target[name] = new Function(\u0026#34;return \u0026#34; + value.toString())(); } else { target[name] = value; } } else { target[name] = value; } } return target; }　}  数组去重的方式有哪些（手写）  // 总结可分为两种 //1.两层循环法 //2.利用语法自身键不可重复性 let a = [2,3,4,1,2,2,4,111,123,321,123]; let b = [...new Set(a)]; // set的原理？  let c = a.filter((item, index) =\u0026gt; { return a.indexOf(item) === index; }) console.log(\u0026#39;a\u0026#39;, a); console.log(\u0026#39;b\u0026#39;, b); console.log(\u0026#39;c\u0026#39;, c); // 其他方法 function unique (arr) { return Array.from(new Set(arr)) } function unique(arr){ for(var i=0; i\u0026lt;arr.length; i++){ for(var j=i+1; j\u0026lt;arr.length; j++){ if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个  arr.splice(j,1); j--; } } } return arr; }  找出数组中最大的数（手写）  // 拿一个变量存max O（n） // 从小到大排序后取最后一位   说一下事件循环的理解 答：JS是单线程，但是需要实现异步动作。浏览器或node环境为了实现异步操作的机制。浏览器执行主线程任务队列，然后micro tasks（timeout的回调，interval回调），然后macro tasks（promise的then回调），然后循环。node：idle，prepare。外部data、connection插入，然后是I/O callback，然后是check，然后是。。忘了。  ┌───────────────────────┐ ┌─\u0026gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │\u0026lt;──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check: setImmediate()的回调会在这个阶段执行。 close callbacks: 例如socket.on(\u0026lsquo;close\u0026rsquo;, \u0026hellip;)这种close事件的回调。\n  快排是如何实现的，讲一下思路和复杂度 答：整体思路是把数组划分为三部分，左边比基准值小，右边的都比基准值大，然后对切分之后的数组再次进行划分\n  如何实现一个观察者模式（手写）\n  如何实现一个单例模式（手写）\n  class Singleton { constructor (name) { this.name = name; if (!Singleton.instance) { Singleton.instance = this; } return Singleton.instance; } } // 将函数作为一个参数传递 var Singleton = function(fn) { var instance return function() { // 通过apply的方式收集参数并执行传入的参数将结果返回  return instance || (instance = fn.apply(this, arguments)) } } // 模拟一个遮罩层 var createDiv = function () { var div = document.createElement(\u0026#39;div\u0026#39;) div.style.width = \u0026#39;100vw\u0026#39; div.style.height = \u0026#39;100vh\u0026#39; div.style.backgroundColor = \u0026#39;red\u0026#39; document.body.appendChild(div) return div } // 创建出这个元素 var createSingleLayer = Singleton(createDiv) document.getElementById(\u0026#39;btn\u0026#39;).onclick = function () { // 只有在调用的时候才展示  var divLayer = createSingleLayer() } // 当然，在实际应用中还是有很多适用场景的，比如登录框，还有我们可能会使用到的 Vux 之类的状态管理工具，它们实际上都是契合单例模式的   如何解析一个 URL，获取 query 和 hash 的参数（手写）  function getHash(url) { // const hash = window.location.hash;  let hashIndex = url.indexOf(\u0026#39;#\u0026#39;); let hash = url.substring(hashIndex + 1); console.log(hash); } let h = \u0026#39;https://juejin.cn/post/6844904088337907720#comment\u0026#39;; getHash(h); function getQuery(url) { // window.location.search ?xxx=ddd  let queryIndex = url.indexOf(\u0026#39;?\u0026#39;); let queryStr = url.substring(queryIndex + 1); let queryObj = {}; queryStr.split(\u0026#39;\u0026amp;\u0026#39;) .forEach(str =\u0026gt; { queryObj[str.split(\u0026#39;=\u0026#39;)[0]] = str.split(\u0026#39;=\u0026#39;)[1]; } ); console.log(queryObj); return queryObj; } let url = \u0026#39;http://localhost:3001/dashboard/list?dashboard=38353\u0026amp;isCore=false\u0026#39;; getQuery(url); function getQueryWithReg(name) { const reg = new RegExp(\u0026#39;(^|\u0026amp;)\u0026#39;+name+\u0026#39;=([^\u0026amp;]*)(\u0026amp;|$)\u0026#39;, \u0026#39;i\u0026#39;); let str = window.location.search.substring(1); let matches = str.match(reg); if (matches !== null) { return matches; } } getQueryWithReg(url);   TypeScript 和 JavaScript 最大的区别在哪\n  Vue和React区别\n 监听数据变化原理不同 vue用Object.defineProperty getter setter（Vue 3用proxy）muttable react 比较引用 需要专门优化PureComponent/shouldComponentUpdate react fiber 数据绑定：vue 双向数据绑定 react单向 必须setState 组合不同功能：React用HoC，vue用mixin（方法重名问题） 组件通信：vue 事件 emit React 回调方法 模板渲染方式：vue html， React JSX 表面上语法不同。深层次上， React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的 Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现。 对这一点，我个人比较喜欢React的做法，因为他更加纯粹更加原生，而Vue的做法显得有些独特，会把HTML弄得很乱。举个例子，说明React的好处： react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。    手写instanceof\nFunction.prototype.myInstanceOf = (instance, type) =\u0026gt; { let proto = instance.__proto__; let prototype = type.prototype; while (proto !== null) { if (proto === prototype) { return true; } proto = proto.__proto__; } return false; } 手写bind\nFunction.prototype.bind = function(objToBind, ...args) { // 调用时这里的this是要bind的函数  const fn = this; return function() { return fn.apply(objToBind, args.concat(...arguments)); } } 手写call\nFunction.prototype.myCall = function(context, ...args) { const ctx = context || window; let fn = Symbol(); ctx[fn] = this; let result = ctx[fn](...args); delete ctx.fn; return result; } 手写apply\nFunction.prototype.myApply = function(context, ...args) { // 调用时这里的this是要bind的函数  const ctx = context || window; let fn = Symbol(); ctx[fn] = this; let result = ctx[fn](args); delete ctx.fn; return result; } js继承\n// https://segmentfault.com/a/1190000015727237 // https://github.com/mqyqingfeng/Blog/issues/16 function Animal (name) { this.name = name; } Animal.prototype.eat = function () { console.log(this.name + \u0026#39; is eating.\u0026#39;); } function Cat(name, gender) { Animal.call(this, name); this.gender = gender; } Cat.prototype = Object.create(Animal.prototype); Cat.prototype.constructor = Cat; // 原型式继承 function inheritObject(o) { let F = function () {}; F.prototype = o; return new F(); } var person = { name: \u0026#39;Kelvin\u0026#39;, friends: [\u0026#39;Amanda\u0026#39;, \u0026#39;Nico\u0026#39;] } var son = inheritObject(person); son.name = \u0026#39;Stephen\u0026#39;; son.friends.push(\u0026#39;Tom\u0026#39;); var son2 = inheritObject(person); son2.name = \u0026#39;Maguire\u0026#39;; son2.friends.push(\u0026#39;Thompson\u0026#39;); console.log(person.friends); // [\u0026#39;Amanda\u0026#39;, \u0026#39;Nico\u0026#39;, \u0026#39;Tom\u0026#39;, \u0026#39;Thompson\u0026#39;] // ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。  // 寄生组合继承 function inheritPrototype (subType, superType) { var prototype = inheritObject(superType.prototype); prototype.constructor = subType; subType.prototype = prototype; } function Parent(name) { this.name = name; this.colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; } Parent.prototype.sayName = function () { console.log(\u0026#39;my name is \u0026#39; + this.name); } function Son(name, age) { Parent.call(this); this.age = age; } inheritPrototype(Son, Parent); Son.prototype.sayAge = function () { console.log(\u0026#39;my age is \u0026#39; + this.age); } // class继承s // 核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。 // 但是，寄生组合继承是先创建子类实例this对象，然后再对其增强；而ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 class A {} class B extends A { constructor() { super(); // super是父类的构造函数，调用了实例  } } // ES6实现继承的具体原理： class A { } class B { } Object.setPrototypeOf = function (obj, proto) { obj.__proto__ = proto; return obj; } // B 的实例继承 A 的实例 Object.setPrototypeOf(B.prototype, A.prototype); // B 继承 A 的静态属性 Object.setPrototypeOf(B, A); ","date":"2021-03-15T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90%E6%96%87%E7%AB%A0%E9%9B%86%E9%94%A6/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90%E6%96%87%E7%AB%A0%E9%9B%86%E9%94%A6/","title":"常见面试题解析文章集锦"},{"content":"flex: flex-grow flex-shrink flex-basis flex-grow 属性定义项目的放大比例，默认值为0，不放大，x为放大x倍 flex-shrink 属性定义了项目的缩小比例，默认值为1，空间不足即缩小，0是不缩小 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）。默认值为auto，项目默认的大小\n   语法 等于 描述 备注     flex: initial flex: 0 1 auto 容器默认不放大，尺寸不足会缩小，尺寸自适应内容 初始值   flex: 0 flex: 0 1 0% 默认放大，尺寸不足会缩小，大小支持0，即最小的内容尺寸 场景少   flex: none flex: 0 0 auto 默认不放大，尺寸不足也不缩小，子项的尺寸就是父级的尺寸时使用    flex: 1 flex: 1 1 0% 可以弹性变大，也可以弹性缩小，尺寸不足时优先最小化内容    flex: auto flex: 1 1 auto 可以弹性变大，也可以弹性缩小，尺寸不足时优先最大化内容 基于内容动态匹配    参考资料：\nFlex 布局教程：语法篇\n","date":"2021-03-09T10:14:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/flex%E5%B8%83%E5%B1%80/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/flex%E5%B8%83%E5%B1%80/","title":"flex布局"},{"content":"Vue的缺点： 全局的this Vue 2 html、data声明、涉及方法代码片段分散，可复用性差\n今日份吐血： 需要重复复制相同逻辑代码，功能代码分散 另一个页面需要使用，则需要复制相应的type action enum，\n上下文丢失 Vue 的单文件组件，使用 、对代码进行分割，直接导致的问题就是上下文丢失。 举个例子，你封装了一些常用的函数，在 Vue 文件中 import 进来。你这个函数能在 template 中直接使用吗？ 不能。 需要在data或者method中中再次声明。 或者用namespace直接定义好action mutation\n模板分割 好的代码组织能将常变与不变的部分进行分割解耦\nVue 的模板严重限制了这一点。 举个例子，前端有个下拉菜单，功能不断增加，而且对于不同的人要显示不同菜单（权限管理）。在 Vue 中，为了实现 html 代码（绑定在 template 中）的分割，你只能再搞一个组件。在 React 中，可以直接这样写：\nconst menu = \u0026lt;div\u0026gt;abc\u0026lt;div\u0026gt;; 可单独做一个组件（低开销函数组件），也可当做变量，放在当前代码中。相对灵活很多。 SX 手写 render 渲染函数自带下面的优势\n 完整的 js 功能来构建视图页面，可以使用临时变量、js 自带的控制流、以及直接引用当前 js 作用域中的值 开发工具对 jsx 的支持比现有 vue 模板先进（linting、typescript、编译器自动补全）  参考资料：\n为什么我们放弃了 Vue？Vue 和 React 深度对比\n","date":"2021-03-09T10:14:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","title":"Web UI 自动化测试实践"},{"content":"Selenium：可以直接在浏览器中运行，目前使用版本v3，最高版本v4（不稳定） 安装、运行：http://www.testclass.net/selenium_python/install-selenium 可能遇到浏览器驱动问题，https://blog.csdn.net/tymatlab/article/details/78649727 http://www.testclass.net/selenium_python/selenium3-browser-driver chrome驱动下载地址：https://sites.google.com/a/chromium.org/chromedriver/home\n元素定位：http://www.testclass.net/selenium_python/find-element 对项目元素设置不同的classsname、css选择器，即可通过以下方法获取到该元素\ndr.find_element_by_class_name(\u0026#34;s_ipt\u0026#34;) dr.find_element_by_css_selector(\u0026#34;#kw\u0026#34;) dr.find_element_by_css_selector(\u0026#34;[name=wd]\u0026#34;) dr.find_element_by_css_selector(\u0026#34;.s_ipt\u0026#34;) dr.find_element_by_css_selector(\u0026#34;html \u0026gt; body \u0026gt; form \u0026gt; span \u0026gt; input\u0026#34;) dr.find_element_by_css_selector(\u0026#34;span.soutu-btn\u0026gt; input#kw\u0026#34;) dr.find_element_by_css_selector(\u0026#34;form#form \u0026gt; span \u0026gt; input\u0026#34;) 控制浏览器操作： http://www.testclass.net/selenium_python/control-browser\n其余操作：包括鼠标事件、键盘事件、窗口切换、文件上传、关闭浏览器等 http://www.testclass.net/selenium_python\ncd ~ // 进入根目录 vim .bash_profile // 创建或者打开该文件\n// .bash_profile以及.bashrc以及.zshrc均输入以下内容 export M2_HOME=/Users/mtdp/project/apache-maven-3.6.3 // /Users/mtdp/project/apache-maven-3.6.3 这个路径是自己存放maven的路径 export M2=$M2_HOME/bin // 不动 export PATH=$M2:$PATH // 不动 export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home // 一般情况下只需要修改jdk版本号就好了，和自己安装的版本号一致，安装mvn和jdk后可以通过mvn -v查询到路径\n// 保存后使用source命令 source .bash_profile/.bashrc/.zshrc\n// java环境配置完成\n// 修改maven的setting文件。进入maven安装目录打开conf下面的settings文件\n 在自己的目录下新建java包存放文件夹，如maven_repostory，我的路径为/Users/mtdp/project/maven_repostory 打开settings.xml文件，修改localRepository路径  /Users/mtdp/project/maven_repostory// 改成自己的路径 meituan-nexus-releasesdeploymentdeployment123\u0026hellip; // 安装python，由于mac本来自带python2，但是如果使用不当可能会引起mac系统崩溃，因此我们使用python3 brew install python3 // 安装python3，如果没有安装brew，使用/bin/bash -c \u0026ldquo;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;安装HOMEbrew pip3 -V // 查看pip是否安装成功 pip3 install selenium // 使用piip安装selenium brew install chromedriver chromedriver \u0026ndash;version // 查看版本 // 我试着直接下载安装包过，但是path总是找不到，运行代码问题频频出现，因此选择命令安装 // 另外安装后一开始不生效的话，建议重开一个终端运行即可\n// 下载仓库代码 git clone ssh://git@git.sankuai.com/qa/case-uiauto.git\n// java运行，进入仓库代码中存放pom.xml层级的目录 mvn test -DxmlFileName=testng.xml\n// 默认用的是test环境， // 如果用本地分支跑，可以把testng.xml中detailUrl修改成localhost:8421/case/product/detail/1295217958986731508?fromRoute=createdCase\u0026amp;pageSize=10\u0026amp;keyword=UI%E8%87%AA%E5%8A%A8%E5%8C%96\u0026amp;offset=2\n测试场景梳理： UI自动化Demo运行需要搭建如下环境：jdk 1.8 + maven + Selenium WebDriver（Selenium 3） 参考资料：\nMac “\u0026lsquo;chromedriver\u0026rsquo; executable needs to be in PATH”\n","date":"2021-03-08T10:54:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/web-ui-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","title":"Web UI 自动化测试实践"},{"content":"冒泡排序 基本思路：从左至右遍历数组，取一个指针指向第一个元素，与下一个元素比较，若该元素更大则前后交换位置，然后指针取下一位，与后一位进行比较，继续这样的循环，这样一轮下来会使得最大值放在数组的末尾，类似吐泡泡一样。之后重新开始循环上述过程，将第二大的元素放在倒数第二位。\nfunction bubbleSort(array) { let isSorted = true; let len = array.length; for (let i = 0; i \u0026lt; len; i ++) { for (let j = 0; (j \u0026lt; len - i - 1); j++) { if (array[j] \u0026gt; array[j + 1]) { isSorted = false; [array[j], array[j + 1]] = [array[j + 1], array[j]]; } } if (isSorted) { break; } else { isSorted = true; } } return array; } 时间复杂度上，最好情况是O(n)，即数组已经完全排好序，后一个元素永远比前一个元素大，不需要冒泡，只需要遍历一次，平均和最坏情况是O(n2)。\n选择排序 基本思路：从左至右遍历数组，比较一圈后得到最小值的索引，与索引0的元素交换位置；接着从第2位开始循环上述操作，将第二小的元素放在索引为1的位置，以此类推。每次遍历的时间为O(n)，这样的时间复杂度为O(n2)。\nfunction selectionSort(array) { for (let i = 0, len = array.length; i \u0026lt; len - 1; i++) { let min = i; for (let j = i + 1; j \u0026lt; len; j++) { if (array[j] \u0026lt; array[min]) { min = j; } } [array[i], array[min]] = [array[min], array[i]] } return array; } 时间复杂度上，最好、平均、最坏情况都是O(n2)。\n插入排序 基本思路：从左至右遍历，新元素通过与左边已经排好序的数组逐一比对，插入至左边的数组中，将比遍历到的元素大的元素统统右移一位。\nfunction insertionSort(array) { for (let i = 0, len = array.length; i \u0026lt; len; i++) { let j = i; const temp = array[j]; while (j \u0026gt; 0 \u0026amp;\u0026amp; temp \u0026lt; array[j - 1]) { array[j] = array[j - 1]; j--; } array[j] = temp; } return array; } 时间复杂度上，最好情况为O(n)，即数组已经完全排好序，平均和最坏情况为O(n2)。\n下面进入到时间复杂度降低了的快速排序和归并排序。\n快速排序quicksort 法一 基本思路：选择一个基准值（随意选择），遍历数组（除基准值以外），将比基准值小的push到一个数组，放到基准值左侧，将比基准值大的push到另一个数组，放到基准值右侧，并对新的两个数组继续递归调用该函数，即为该函数的返回结果。基线条件为入参数组的长度为1，结束递归，直接返回该数组。递归过程逐个栈完成调用返回结果。\nfunction quickSort(array) { if (array.length \u0026lt; 2) { return array; } let pivot = array[0]; let low = []; let high = []; for (let i = 1; i \u0026lt; array.length; i++) { if (array[i] \u0026lt;= pivot) { low.push(array[i]); } else { high.push(array[i]); } } return quickSort(low).concat(pivot, quickSort(high)); } 每层实际还是遍历了O(n)个元素，而调用栈共有O(logn)层（相当于二分，所以是2的对数），所以平均情况的时间复杂度为O(n) * O(log n) = O(nlogn)。 最糟情况下，例如一个已经排好序的数组，基准值从第一个元素取，则右边分出来的数组拆分为原长度减1的数组，所以调用栈为n层，此时时间复杂度为O(n2)。但是一般都不会遇到最糟情况。\n法二 实现分析：\n将当前数组分区 分区时先选择一个基准值，再创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直至找到一个比基准值大的元素，再移动右指针直至找到一个比基准值小的元素，然后交换它们，重复这个过程，直到左指针的位置超过了右指针。如此分区、交换使得比基准值小的元素都在基准值之前，比基准值大的元素都在基准值之后，这就是分区（partition）操作。 对于上一次分区后的两个区域重复进行分区、交换操作，直至分区到最小。\nfunction quickSort(unsorted) { function partition(array, left, right) { const pivot = array[ Math.floor((left + right) / 2) ]; while (left \u0026lt;= right) { while (array[left] \u0026lt; pivot) { left++; } while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { [array[left], array[right]] = [array[right], array[left]]; left++; right--; } } return left; } function quick(array, left, right) { if (array.length \u0026lt;= 1) { return array; } const index = partition(array, left, right); if (left \u0026lt; index - 1) { quick(array, left, index - 1); } if (right \u0026gt; index) { quick(array, index, right); } return array; } return quick(unsorted, 0, unsorted.length - 1); } 时间复杂度上，最好、平均复杂度是O(nlogn)，最坏情况是O(n2)\n法三 function quickSort (array) { if (array.length \u0026lt; 2) { return array; } let pivot = array[array.length - 1]; let left = array.filter((v, i) =\u0026gt; v \u0026lt; pivot \u0026amp;\u0026amp; i !== array.length - 1); let right = array.filter(v =\u0026gt; v \u0026gt; pivot); return [...quickSort(left), pivot, ...quickSort(right)]; } 合并排序mergesort 基本思路：取位于数组中间的值，将左侧右侧各生成一个新数组（split），然后调用merge函数，各用一个索引进行逐个遍历比较，将较小的推送至结果数组中，直至其中一个数组遍历结束，对有剩余元素的那个数组在尾部加至结果数组。对新数组递归拆分操作，并调用该merge函数，直至左右数组的长度为1。\n将数组从中间切分为两个数组 切分到最小之后，开始归并操作，即合并两个已排序的数组 递归合并的过程，由于是从小到大合并，所以待合并的两个数组总是已排序的，一直做同样的归并操作就可以\nfunction mergeSort(array) { function merge(arrL, arrR) { let indexL = indexR = 0; const lenL = arrL.length; const lenR = arrR.length; const result = []; while (indexL \u0026lt; lenL \u0026amp;\u0026amp; indexR \u0026lt; lenR) { if (arrL[indexL] \u0026lt;= arrR[indexR]) { result.push(arrL[indexL++]); } else { result.push(arrR[indexR++]); } } while (indexL \u0026lt; lenL) { result.push(arrL[indexL++]) } while (indexR \u0026lt; lenR) { result.push(arrR[indexR++]) } return result; } function split(array) { if (array.length === 1) { return array; } const mid = Math.floor(array.length / 2); const arrL = array.slice(0, mid); const arrR = array.slice(mid); return merge(split(arrL), split(arrR)); } return split(array); } function mergeSort(array) { function merge(arrL, arrR) { let indexL = indexR = 0; const lenL = arrL.length; const lenR = arrR.length; const result = []; while (indexL \u0026lt; lenL \u0026amp;\u0026amp; indexR \u0026lt; lenR) { if (arrL[indexL] \u0026lt;= arrR[indexR]) { result.push(arrL[indexL++]); } else { result.push(arrR[indexR++]); } } while (indexL \u0026lt; lenL) { result.push(arrL[indexL++]) } while (indexR \u0026lt; lenR) { result.push(arrR[indexR++]) } return result; } if (array.length === 1) { return array; } const mid = Math.floor(array.length / 2); const arrL = array.slice(0, mid); const arrR = array.slice(mid); return merge(mergeSort(arrL), mergeSort(arrR)); } 时间复杂度上，最好、平均和最坏情况都是 O(nlog(n))。空间复杂度是O(n)。\n对比归并排序与快速排序  都用了分治的思想。相比选择排序和冒泡排序，归并排序与快速排序使用了切分而不是直接遍历，这有效减少了交换次数。 归并排序是先切分、后排序，过程可以描述为：切分、切分、切分……排序、排序、排序…… 快速排序是分区、排序交替进行，过程可以描述为：分区、排序、分区、排序…… 上两条所说的“排序”，在归并排序与快速排序中并非同样的操作，归并排序中的操作是将两个数组合并为一（归并操作），而快速排序中的操作是交换。 归并排序，由小及大，小的排好序的数组递归合并为大的排好序的数组，逐渐递归覆盖到整个原始数组；快速排序，由大及小，先将大的整个数组根据基准值进行大小分区，再逐渐切小，对小的分区进行大小分区。  以上集中排序方式的时间复杂度和空间复杂度如下图所示：   sorting algorithm  空间复杂度分析：\n堆排序：todo 树排序：todo\n参考资料： 归并排序与快速排序的简明实现及对比\n","date":"2021-02-26T19:11:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/array_sorting_algorithm_huec1666719498bd6a587a8e0b2a8ad6f2_69768_120x120_fill_box_smart1_2.png","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"JavaScript实现常见排序算法"},{"content":"临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。\n为帮助 Node.js 开发人员更好的面试，我列出了 15 个常见的 Node.js 和网络开发相关的面试问题。\n在本文中，我们将重点讨论 Node.js 相关问题。但是，请记住 JavaScript 问题在 Node.js 面试中也经常问到，所以准备一些对你来说没什么坏处。不久前我们写了一篇关于常见 JavaScript 面试问题的帖子，涵盖了所有这些基础。\nhttps://livecodestream.dev/post/20-common-javascript-interview-questions/\n现在，让我们深入了解面试中可能会问到的 Node.js 问题。\n Node.js 与 JavaScript 有什么不同?    Image \n什么时候用 Node.js？ Node.js 是异步的、事件驱动的、非阻塞的和单线程的，使得它成为开发下面应用程序的完美候选：    实时应用程序，如聊天和提供实时更新的应用程序\n  将视频或其他多媒体内容流式传输给大量观众的流式应用程序\n  其他 I/O 密集型应用程序，如协作平台\n  遵循微服务架构的网络后端\n  然而，Node.js 的特性使得它对于其他类型的应用程序来说不是一个理想的选择。执行 CPU 密集型任务的应用程序（如复杂的数学计算）在使用 CPU 时表现不佳，因为 Node.js 是单线程的。\nEventEmitter 做了什么？ Node.js 中任何对象发出的事件都是 EventEmitter 类的实例，就像 http 模块。  所有 EventEmitter 类都可以使用 eventEmitter.on() 函数将事件侦听器附加到事件。然后一旦捕捉到这样的事件，就会同步地逐个调用它的侦听器。\nconst events = require(\u0026#34;events\u0026#34;); const eventEmitter = new events.EventEmitter(); const eventListener = function(){ console.log(\u0026#34;event triggered\u0026#34;); } eventEmitter.on(\u0026#34;emitted\u0026#34;, eventListener); eventEmitter.emit(\u0026#34;emitted\u0026#34;); 事件循环是什么?  单线程的 Node.js 必须是非阻塞的，以防止线程阻塞在需要很长时间才能完成的任务上，事件循环负责实现这种非阻塞行为，它使用应用程序线程调度挂起的任务。\nNode.js 在任务完成时通过回调来处理异步函数返回的响应。与创建任务的事件类似，任务完成后也会发出一个事件。Node.js 将需要处理的事件添加到事件队列。\n事件循环对事件队列中的事件进行迭代，并安排何时执行其关联的回调函数。\n流是什么?  Stream 流是从源读取或写入数据并将其传输到连续流目标的管道。有四种类型：\n  可读\n  可写的\n  可读写\n  先写入，再读出来\n  每个流也是一个 EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件。\nconst fs = require(\u0026#34;fs\u0026#34;); const readableStream = fs.createReadStream(\u0026#34;test.txt\u0026#34;); let content = \u0026#34;\u0026#34;; readableStream.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { content += chunk; }); readableStream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(content); }); readFile 和 createReadStream 函数有什么区别？  readFile 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。\ncreateReadStream 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。\n与 readFile 相比，createReadStream 使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会先向用户发送小块内容。\nconst fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#34;test.txt\u0026#34;, (err, content) =\u0026gt; { console.log(content); }); 如何处理 Node.js 中未捕获的异常？  我们可以在进程级别捕获应用程序中未捕获的异常。为此将侦听器附加到 process 全局对象：\nprocess.on(\u0026#34;uncaughtException\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;exception caught: \u0026#34;, err); }); Node.js 能否充分利用多核处理器？ （默认的）Node.js 应用程序总是单线程的，即使在多核处理器上运行，应用程序也能只使用一个处理器。  但是 Node.js 的核心模块之一 Cluster 支持 Node.js 应用程序开启多核，允许我们创建多个工作进程，这些进程可以在多个内核上并行运行，并共享一个端口来侦听事件。\n每个进程使用 IPC 与主线程通信，并根据需要将服务器句柄传递给其他进程。主进程可以侦听端口本身并以循环方式将每个新连接传递给子进程，也可以将端口分配给子进程以便子进程侦听请求。\n反应堆设计模式是什么？ 反应堆设计模式是，Node.js 将回调函数（处理程序）附加到每个 I/O 操作，然后创建请求时将处理程序提交给解复用器。  解复用器收集应用程序中发出的每个 I/O 请求，并将它们作为队列中的事件进行排队。这个队列就是我们所说的事件队列。将事件排队后，解复用器返回应用程序线程的控制。\n同时，事件循环遍历事件队列中的每个事件，并调用附加的回调来处理事件响应。\n这就是 Node.js 中所使用的反应堆模式。\n单线程与多线程网络后端相比有哪些好处？  尽管 Node.js 是单线程的，但是大多数用于后端开发的编程语言都提供多线程来处理应用程序操作。而为什么单线程有利于后端开发？\n开发人员更容易实现应用程序。我们的应用程序在生产过程中不会突然遇到意外的竞争条件。\n单线程应用程序易于扩展。\n它们可以毫不延迟地在一个时刻收到的大量用户请求提供服务。相比之下，当流量较大时，多线程后端必须等待线程池中的线程释放，才能为用户请求提供服务。利用 Node.js 的非阻塞特性，用户请求不会在单个线程上挂起太长时间（只有在操作不是 CPU 密集型时）。\nREPL 是什么？  REPL 代表 Read Eval Print Loop，是一个虚拟环境，可以在其中轻松地运行编程语言。Node.js 带有一个内置的 REPL 来运行 JavaScript 代码，类似于我们在浏览器中用来运行 JavaScript 代码的控制台。\n要启动 Node.js REPL，只需在命令行上运行 node，然后写一行 JavaScript 代码，就可以在下一行看到它的输出。\nprocess.nextTick 和 setImmediate 有什么区别？ 传递给 setImmediate 函数的回调将在事件队列上的下一次迭代中执行。  另一方面，回调传递给 process.nextTick 在下一次迭代之前以及程序中当前运行的操作完成之后执行。在应用程序启动时，开始遍历事件队列之前调用它的回调。\n因此，回调 process.nextTick 总是在 setImmediate 之前调用。\n下面代码段：\nsetImmediate(() =\u0026gt; { console.log(\u0026#34;first\u0026#34;); }) process.nextTick(() =\u0026gt; { console.log(\u0026#34;second\u0026#34;); }) console.log(\u0026#34;third\u0026#34;); 将按顺序输出： third second first 13. stub 是什么? 测试应用程序时使用 stub，模拟给定组件或模块的行为，你可以将精力集中在要测试的代码部分。通过使用 stub 代替与测试无关的组件，不必担心外部组件会影响结果。\n例如，如果正在测试的组件在预期测试的部分之前有一个文件读取操作，则可以使用 stub 来模拟该行为并返回模拟内容，而不用实际读取文件。\n在 Node.js 中，我们使用像 Sinon 这样的库来实现（译者注，Sinon 在测试中替换某部分代码，减少测试项编写的复杂度 https://sinonjs.org）。\n为什么在 express 中分离“应用程序”和“服务器”是一种好的做法？ 通过在 Express 中分离应用程序和服务器，可以将 API 实现与网络相关配置分开。在不执行网络调用的情况下执行 API 测试，保证了更快的测试执行和更好的代码覆盖度量。  要实现这种分离，应该在单独的文件中声明 API 和 server，对应 app.js 和 server.js：\n// app.js const express = require(\u0026#34;express\u0026#34;); const app = express(); app.use(\u0026#34;/\u0026#34;, index); app.use(\u0026#34;/contact\u0026#34;, contact); app.use(\u0026#34;/user\u0026#34;, user); module.exports = app; // server.js const http = require(\u0026#34;http\u0026#34;); const app = require(\u0026#34;/app\u0026#34;); app.set(\u0026#39;port\u0026#39;, process.env.PORT); const http = http.createServer(app); 什么是 yarn 和 npm？为什么要用 yarn 代替 npm 呢？ npm 是与 Node.js 自带的默认包管理器，它有一个大型的公共库和私有库，存储在 npm registry 的数据库中（译者注，官方默认中心库 http://registry.npmjs.org/，国内淘宝镜像 http://registry.npm.taobao.org/），用户可以通过 npm 命令行访问该数据库。在 npm 的帮助下，用户可以轻松管理项目中的依赖项。  yarn 也是一个包管理器，为了解决 npm 的一些缺点。yarn 依赖 npm 注册中心为用户提供对包访问。yarn 底层结构基于 npm，如果从 npm 迁移到 yarn，项目结构和工作流不需要大改。\n就像之前提到的，在某些情况下，yarn 提供了比 npm 更好的功能。与 npm 不同的是，它会缓存下载的每个包，不必重新下载。\n通过校验和验证包的完整性来提供更好的安全性，保证在某个系统上运行的包在任何其他系统中的工作方式完全相同，这就是为什么选择 yarn 而不是 npm 来进行包管理。\n结论 在本文中，讨论了 15 个最常见的 Node.js 面试问题，帮助你为下一次面试做准备。知道你可能被问到的问题和答案，面试就不再紧张了。\n祝你好运，面试成功！临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。\n参考资料：\n15 个常见的 Node.js 面试问题及答案\n","date":"2021-02-22T19:23:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/node.js-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%9815%E6%9D%A1/640_hu992ded1d4f7b7b2034fd8a8bad8be327_108856_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/node.js-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%9815%E6%9D%A1/","title":"Node.js 常见问题15条"},{"content":"  自我介绍的模板 突出能力 ✅\n突出兴趣 突出性格\n之后！！！重要！！！！对自己进行总结+求职意向的说明\n  申请岗位的理由，有自己的话复述一下岗位要求： 看好行业岗位前景/我的个人兴趣/非常适合发挥我的能力\n  结合自己的介绍，阐述自己为什么适合这个岗位，总结匹配性 我过去的经历，已经储备了xx能力（重复一下具体能力名称），我自己也是一个xx的人（具体的性格特点价值观） 我觉得xx的经历对我申请这个岗位有很大帮助（引导面试官后续询问亮点经历）。除了工作之外，我平时还喜欢xx，也对我申请这个岗位有帮助。（爱好、兴趣，能够说明你的性格特点价值观，切记匹配岗位要求）\n  自我介绍要点： 3分钟串联经历，给经历做总结，最后重申自己为什么申请这个岗位，为什么适合这个岗位。\n  详细介绍过往经历 面试官可能会问：详细介绍一下你在xx的工作经历？能具体介绍一下xx项目的过程吗？ ！！！拒绝流水账！！！重点是展示具体能力、工作方法和态度、特长 这里可以运用STAR原则 situation task action reuslt\n(1) 情景 —— 这个情景有多重要？ 面试官会根据这个判断你是否收到重用。 可以增加以下表述： 我所在的这个组是公司当时重点发力的部门/公司主营业务部门； 我们这个项目当时是为了解决平台的新增xx需求\n岗位如下三类，可以进行下下归类： 主营业务岗位/主营业务相关项目 —— 公司当下最重要的部门 创新业务线/创新项目 —— 公司的未来 业务核心支撑部门 —— 稳定性、持续性的部门\n(2) 任务 —— 你的任务独特性是什么？ 任务的独特性能够通过过往经历更好地体现你的能力、性格、价值观。独特性主要分为以下三种： 独立完成型 —— 独自承担某项工作，要介绍细节 （能力认可） 横向对比型 —— 同样类型工作，和其他同事比，特色之处 （优势） 体现能力型 —— 对难点进行抽象，协调能力/短时间高强度/认真细致/快速学习\n(3) 行动 —— 你工作的亮点是什么？ 亮点大致可以分为以下五种： 高举高打型 —— 专业、深度、超越同级别/年龄工作者的方法 努力拼搏型 —— 花时间、精力 独立思考型 —— 用和别人不同的方式 善用资源型 —— 解决问题，借助外部资源 克服困难型 —— 突出任务中的矛盾，体现自己能力\n(4) 结果 —— 有多超预期？ 不要出现假大空的词汇，例如 大量、很多、显著、广泛、非常，尽量使用具体数字、事实，并且要给一个参照系\n  和自己比 系统效率提升了xx，收入提升了xx，费率降低了xx，超额完成KPIxx 和别人比 排名前xx%，比别人快xx%\n  额外价值 优化了流程，标准化了工序，自动化了工作，开辟新渠道，学习了xx技能\n  总结要点：STAR结构化阐述，S突出重要性，T突出独特性，A突出亮点，R突出超预期。\n  如何回答专业问题 (1) 有标准答案的问题 首先基础知识、题库刷起来！ 考验临场表现的难题： a。 10秒想不出来的问题，先套话。 “这个问我我需要组织一下思路/思考一下/回忆一下/准备一下” 三个要点：\n 正视面试官 —— 表现冷静 笔记本 —— 写写画画，减压 思考不超过30秒 —— 避免空气凝固  b。表示不知道，但是知道答案的大概范围/思路 让面试官了解到虽然暂时回答不上来，但是知道是哪个领域的，回去补课的话可以掌握。\nc。表示不知道，但是可以回答类似问题，并且给出答案 xxx不太熟悉，用的比较少，我用过其他xxx，可以介绍一下吗？ —— 考察知识技能之外，还看表达能力、逻辑性，避免被动地被面试官发现更多不熟悉\n(2) 开放性问题 主要考察表达、逻辑、沟通、知识深度和广度。 三个要点：\n 垫话 “稍微准备一下” 然后把要点写在笔记本上。这样可以进行缓冲 用词专业 回答时尽量用专业术语 提前准备面经 把所有真题都认真吸收。开放性问题要自己尝试写答案，掌握方法而不是死记硬背。    如何回答个人问题 (1) 为什么离开上一家？ ❌ 毫无主见型 大家都。。。 ❌ 抱怨型 没发展。。气氛差。。 ✅ 前景美好型 公司的美好前景+具体细节 公司的发展势头 市场快速发展 公司战略明确，对员工更有上升空间 公司技术/商业模式更好 岗位需求在扩大 学到/得到更多知识或者经验\n✅ 个人兴趣型 公司的xx + 详细解释 贵公司的工作内容 贵公司岗位使用的技术 贵公司的工作节奏、气氛\n✅ 发挥价值型 我的技术/知识/背景/性格 + 算账/对比\n(2) 自我评价 优缺点/你是个什么样的人？\n第一，先认真评价一下自己 回顾bbc 第二，找一下目标公司、目标岗位需要什么样的人 JD中都会提到，对比一下。软性实力、个人特点和岗位是否匹配？ 第三，取交集\n谈个人特点、优点，可以使用三段论： 我是一个xx的人，xxx比较强，xxx是我的一个优点。 —— 结论 比如我之前xxx，我平时xxx —— 事实支撑，更可信 在这个岗位上，我能发挥/适应/解决xxx —— 强化你的优点与目标岗位需求的关系\n如果明确问了缺点？ ❌ 过分实在型 粗心、情绪起伏大。。。 ❌ 明贬暗褒型 工作太拼。。。 ❌ 避重就轻型 不注意着装。。。 ❌ 答不出来型 。。。。\n✅ 主要工作的次要技能，说自己有待提高。 介绍背景+主要矛盾的次要方面。 作为xxx，xxx比较扎实，但是对xxx这块不是很熟悉。 我也在多和同时学习，提升这部分能力。\n✅ 用详细的描述让缺点变成特点 特点+具体场景+解决方案\n(3) 职业规划 短期职业规划是面试官最关心的。需要体现稳定性。 实现的目标短期掌握哪些能力、解决什么问题、成为哪一种更高职位的人才 看一看比自己高1-2个职级的人。再看JD。和业内资深人士交流。 提高或者实现的路径 工作中学习哪些技能、提升经验、业余时间如何提高，展示未来3-5年的成长思路。如果很清楚短板，就具体描述如何提高短板。\n重点：目标明确、路径清晰。这会向面试官展示出稳定性、成长性。 我希望xx年后可以开始独立负责xx项目 —— 明确目标 短期内我会xxx，xxx。xxx。 —— 路径\n(4) 其他问题 注意回答问题要和之前体现出的个人性格、价值观、自我介绍保持一致。\n  如何给公司提问题 ！！不要问公开可以搜索到的问题 非HR：职业发展的路径，工作氛围，团队工作节奏 部门在公司定位 战略级产品类型 技术栈 具体分工 部门发展规划 主要客户群体\n反馈或追问 对个人提升的关心 入职后培训体系 职业发展路径 今生 未来1年什么成果\n结合自己的背景 进行追问/反馈。\n  除了当场面试之外的三个细节 (1) 排练 语速适中 声音适中 音调适中 平视 目光正直 身体不要乱动 (2) 面试当天 早去 熟悉场地气氛 找人闲聊 前台、HR、其他面试者，进入与人沟通的情景 临走留个联系方式，加微信 表示感谢 询问是否需要补充材料 录取了：提前聊一聊 没录取：打个招呼，再次感谢 (3)\n  ","date":"2021-01-12T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/ji%E6%8A%80%E5%B7%A7/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/ji%E6%8A%80%E5%B7%A7/","title":"JI技巧"},{"content":"WebSocket 工作在七层（或者四层）中的哪一层？和 HTTP 是什么关系？ 是基于 UDP 的还是 TCP 的？ TCP 为什么是三次握手？为什么是四次挥手？ CDN 的工作原理是什么？ 运营商劫持是什么？如何防范？ HTTPS 一定是安全的么？如果不是，那么在什么情况下是不安全的？ 如何劫持 HTTPS 请求。 比如你需要抓 HTTPS 的包，怎么做？ 支付宝和微信的离线支付是怎么做的？ Token 和 Cookie 有什么区别和联系呢？其分别是为了解决什么样的事情？ WebSocket 需要 cookie 么？为什么？ WebSocket 是怎么实现点对点通信和广播通信的？ 如果访问你的 APP 很慢，你自己无法重现。 初步定位到网络问题， 那么你怎么能具体定位到问题呢？ traceroute, Ping 的原理是什么？ 192.168.0.1 和 192.168.1.1 如何通信？ DNS 是如何泄漏个人隐私的？怎么防范？ 从网络协议模型（七层 or 四层）的角度分析一下，浏览器访问 192.168.3.4:8088 的具体过程。\n","date":"2021-01-12T12:20:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BA%8C%E7%BD%91%E7%BB%9C/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BA%8C%E7%BD%91%E7%BB%9C/","title":"前端知识汇总（二）：网络"},{"content":"事件模型 不论是浏览器还是Node.js，都有自己的事件模型，它们都是事件驱动的，即依靠事件来维持运行。 现在比较推荐的绑定事件的方法是addEventListener：\ntarget.addEventListener(type, listener[, options]); target.addEventListener(type, listener[, useCapture]); target.addEventListener(type, listener[, useCapture, wantsUntrusted ]); // Gecko/Mozilla only 旧版本的第三个参数是bool，表示是否是捕获阶段，默认是false，即默认为冒泡阶段。新版本是一个对象，其中有capture（和上面功能一样），passive和once。once用来执行是否只执行一次，passive如果被指定为true, 表示永远不会执行preventDefault(),这在实现丝滑柔顺的滚动的效果中很重要。Improving scrolling performance with passive listeners\n框架中的事件 框架中的事件 实际上，我们现在大多数情况都是用框架来写代码，因此上面的情况其实在现实中是非常少见的，我们更多看到的是框架封装好的事件，比如React的合成事件，感兴趣的可以看下这几篇文章。\n React SyntheticEvent Vue和React的优点分别是什么？两者的最核心差异对比是什么？  虽然我们很少时候会接触到原生的事件，但是了解一下事件对象，事件机制，事件代理等还是很有必要的，因为框架的事件系统至少在这方面还是一致的，这些内容我们接下来就会讲到。\n事件对象 function handleClick(e: Event) { // ... } 这个e就是事件对象，它包含一些重要属性和方法：\n 属性   target x, y等位置信息 timeStamp eventPhase   方法   preventDefault 用于阻止浏览器的默认行为，比如a标签会默认进行跳转，form会默认校验并发送请求到action指定的地址等 stopPropagation 用于阻止事件的继续冒泡行为，后面讲事件传播的时候会提到。  事件循环 事件指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。循环指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。 一段JS代码，需要被编译成机器可理解并执行的指令，这就依赖JS引擎。而V8引擎中，有两个核心组成，即执行栈和堆。执行栈中存放正在执行的代码段，堆中存放变量的值。以一段简单代码为例：\nfunction c() {} function b() { c(); } function a() { b(); }a(); 代码执行的过程可以用动图表示：   call stack \nDOM和Web API JS对应的ECMA规范，V8只有堆和栈，用来实现ECMA规范，它与DOM（文档对象模型，其提供了一系列可以供JS调用的接口）、Web API、事件循环等执行环境如浏览器包含的内容不相关。 JS执行栈与渲染线程互相阻塞，为的是避免并行时JS获取DOM信息之后对DOM进行操作，而DOM本身同时也发生了变化，这样就会导致错乱和冲突。\n单线程同步、多线程同步、异步 fetchUserInfoSync().then(doSomethingA); // 1s fetchMyArcticlesSync().then(doSomethingB);// 3s fetchMyFriendsSync().then(doSomethingC);// 2s 在单线程的情况下，由于JS与渲染线程互相阻塞，因此发出三个接口异步请求时后续代码都被阻塞，数据需要耗时6s，这显然是不可接受的； 在多线程的情况下，最理想状态下需要耗时3s，但是因为三个线程都可以访问DOM和堆内存，很可能造成冲突，若要避免冲突就要设计锁🔒，这样会导致代码模型更加复杂，耗时必然大于3s； 在异步的情况下，就涉及到事件循环。\n事件循环如何实现异步 事件循环在浏览器和NodeJs中都是用于调度的，它决定了V8什么时候执行什么代码。V8只是负责JS代码的解析和执行，其他一概不知。 浏览器或者NodeJS中触发事件之后，到事件的监听函数被V8执行这个时间段的所有工作都是事件循环在起作用。 我们来小结一下：\n对于V8来说，它有： 调用栈（call stack） 这里的单线程指的是只有一个call stack。只有一个call stack 意味着同一时间只能执行一段代码。\n堆（heap） 对于浏览器运行环境来说： WEB API DOM API 任务队列 事件来触发事件循环进行流动\n事件循环之所以可以实现异步，就是将类似setTimeout等异步执行的代码注册/绑定的回调函数存起来，后面再将任务推入执行栈中。如图所示：\nfunction c() {} function b() { c(); } function a() { setTimeout(b, 2000) } a();   setTimeout \n加入用户交互之后，可见示例： http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\nsetTimeout代码执行后会将回调函数放入Web API中，计时结束后注册的回调函数会插入Callback queue中，待到Call Stack为空即浏览器空闲的时候时排队插入Call Stack被执行。\n加入宏任务和微任务，来看一个更复杂的例子：\nconsole.log(1) setTimeout(() =\u0026gt; { console.log(2) }, 0) Promise.resolve().then(() =\u0026gt; { return console.log(3) }).then(() =\u0026gt; { console.log(4) }) console.log(5) 上面的代码会输出：1、5、3、4、2。 如果你想要非常严谨的解释可以参考 whatwg 对其进行的描述 cievent-loop-processing-model。\n下面我会对其进行一个简单的解释。\n 浏览器首先执行宏任务，也就是我们script（仅仅执行一次） 完成之后检查是否存在微任务，然后不停执行，直到清空队列 执行宏任务 其中：  宏任务主要包含：setTimeout、setInterval、setImmediate、I/O、UI交互事件\n微任务主要包含：Promise、process.nextTick、MutaionObserver 等\n  事件循环示意图 \n有了这个知识，我们不难得出上面代码的输出结果。\n由此我们可以看出，宏任务\u0026amp;微任务只是实现异步过程中，我们对于信号的处理顺序不同而已。如果我们不加区分，全部放到一个队列，就不会有宏任务\u0026amp;微任务。这种人为划分优先级的过程，在某些时候非常有用。\n加入执行上下文栈 说到执行上下文，就不得不提到浏览器执行JS函数其实是分两个过程的。一个是创建阶段Creation Phase，一个是执行阶段Execution Phase。\n同执行栈一样，浏览器每遇到一个函数，也会将当前函数的执行上下文栈推入栈顶。\nfunction a(num) { function b(num) { function c(num) { const n = 3 console.log(num + n) } c(num); } b(num); } a(1); 遇到上面的代码。 首先会将a的压入执行栈，我们开始进行创建阶段Creation Phase， 将a的执行上下文压入栈。然后初始化a的执行上下文，分别是VO，ScopeChain（VO chain）和 This。 从这里我们也可以看出，this其实是动态决定的。VO指的是variables, functions 和 arguments。 并且执行上下文栈也会同步随着执行栈的销毁而销毁。\n伪代码表示：\nconst EC = { \u0026#39;scopeChain\u0026#39;: { }, \u0026#39;variableObject\u0026#39;: { }, \u0026#39;this\u0026#39;: { } }   execution context stack  我们来重点看一下ScopeChain(VO chain)。如上图的执行上下文大概长这个样子，伪代码：\nglobal.VO = { a: pointer to a(), scopeChain: [global.VO] } a.VO = { b: pointer to b(), arguments: { 0: 1 }, scopeChain: [a.VO, global.VO] } b.VO = { c: pointer to c(), arguments: { 0: 1 }, scopeChain: [b.VO, a.VO, global.VO] } c.VO = { arguments: { 0: 1 }, n: 3 scopeChain: [c.VO, b.VO, a.VO, global.VO] } 引擎查找变量的时候，会先从VOC开始找，找不到会继续去VOB…，直到GlobalVO，如果GlobalVO也找不到会返回Referrence Error，整个过程类似原型链的查找。\n值得一提的是，JS是词法作用域，也就是静态作用域。换句话说就是作用域取决于代码定义的位置，而不是执行的位置，这也就是闭包产生的本质原因。 如果上面的代码改造成下面的：\nfunction c() {} function b() {} function a() {} a() b() c() // 或者这种 function c() {} function b() { c(); } function a() { b(); } a(); 其执行上下文栈虽然都是一样的，但是其对应的scopeChain则完全不同，因为函数定义的位置发生了变化。拿上面的代码片段来说,c.VO会变成这样：\nc.VO = { scopeChain: [c.VO, global.VO] } 也就是说其再也无法获取到a和b中的VO了。 一图总结本文如下：   v8_engine.jpg \n参考资料： 《一文看懂浏览器事件循环》\n","date":"2020-12-28T12:03:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/cover_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","title":"前端知识汇总（一）：浏览器事件模型和事件循环"},{"content":"项目结构优化 Vue Router 现在分为三个模块：\n History 实现： 处理地址栏，并且特定于 Vue Router 运行的环境（节点，浏览器，移动设备等） Router 匹配器：处理类似 /users/:id 的路由解析和优先级处理。 Router: 将一切连接在一起，并处理路由特定功能，例如导航守卫。  |____types | |____typeGuards.ts // 对route进行校验 | |____index.ts // type和interface |____router.ts // connects everything together and handle routing specific features like navigation guards |____RouterLink.ts |____errors.ts |____globalExtensions.ts |____injectionSymbols.ts |____utils | |____callbacks.ts | |____README.md | |____index.ts | |____env.ts |____devtools.ts |____location.ts |____matcher // handles the parsing of routes /users/:id and its ranking | |____pathTokenizer.ts // path解析器，生成token数组tokenizePath | |____pathMatcher.ts // 提供createRouteRecordMatcher方法供index调用，在addRoute时创建matcher | |____pathParserRanker.ts // 对每一个setment计算score | |____types.ts // 定义RouteRecordNormalized作为RouteRecord | |____index.ts // 定义并实现RouterMatcher，内部定义matcherMap路由映射；对RouteRecord、RouteProps进行normalize |____warning.ts |____RouterView.ts |____scrollBehavior.ts |____history // handles the address bar and is specific to the environment Vue Router runs on (Node, Browser, Mobile, etc) | |____common.ts // 列举一些通用的用于History API的interface、type、enum和在两个模式下通用的方法 | |____hash.ts // hash模式，createWebHashHistory | |____html5.ts // html5模式，createWebHistory | |____memory.ts // abstract模式，createMemoryHistory, 记录路由队列、监听器和当前位置，实现router方法。如果发现没有浏览器的 API，路由会自动强制进入这个模式 |____global.d.ts |____useApi.ts |____index.ts |____query.ts |____encoding.ts |____navigationGuards.ts // 路由守卫 // src/history/html5.ts /** * Creates a normalized history location from a window.location object * @param location - */ function createCurrentLocation( base: string, location: Location ): HistoryLocation {} function useHistoryListeners(base: string, historyState: ValueContainer\u0026lt;StateEntry\u0026gt;, currentLocation: ValueContainer\u0026lt;HistoryLocation\u0026gt;, replace: RouterHistory[\u0026#39;replace\u0026#39;] ){} function useHistoryStateNavigation(base: string) {} export function createWebHistory(base?: string): RouterHistory {} 动态路由 Vue Router3 { // 会匹配所有路径 path: '*' } { // 会匹配以 `/user-` 开头的任意路径 path: '/user-*' } vue-router 3使用 path-to-regexp 作为路径匹配引擎。 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。当使用通配符路由时，必须确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: \u0026lsquo;*\u0026rsquo; } 通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。\nVue Router 4 不再使用path-to-regexp，而是使用自己的转化系统。新增了有自动优先级排名的高级路径解析功能，用户新现在可以以随意的顺序定义路由，因为 Router 会根据 URL 字符串表示来猜测应该匹配的路由。 举个例子来说，你同时写了 /users 和 /:w+ 这两个路由：\nconst routes = [ { path: \u0026#39;/users\u0026#39;, Component: Users }, { path: \u0026#39;/:w+\u0026#39;, Component: NotFound } ] 那么你当然希望在输入 /users 这个更精确的路径的时候，走上面的规则，而下面则作为兜底规则。在旧版的 Vue Router 中需要通过路由声明的顺序来保证这个行为，而新版则无论你怎样放置，都会按照得分系统来计算该匹配哪个路由。\n甚至专门有 Path Ranker这个网页来帮助你计算路由的优先级得分。 简单来说，越明确的路由排名越高，越模糊则反之，无关顺序，非常有意思。\n改进后的导航系统 新的导航系统更加具有一致性，它改善了滚动行为的体验，使其更加接近原生浏览器的行为。 它还为用户提供了有关导航状态的几乎更多信息，用户可以用这些信息，通过 ProgressBar和 Modal之类的全局 UI 元素让用户的体验变得更好。 改进动机：\n 先前的selector默认使用document.querySelector。但是这个API不支持 /^#\\d/即以数字开头的id元素，所以vue3团队决定针对这种参数使用getElementById。但是这个API仍不适用于选择某个id元素内的某个class的元素，比如#1one .container。诸如此类的情况都会导致vue-router抛出document.querySelector failed，让用户产生困惑。  { x: number, y: number } { selector: string, offset? : { x: number, y: number }} 基于Element.scrollTo的参数配置ScrollToOptions，vue-router 4进行了改造  // vue router 3 scrollBehavior (to, from, savedPosition) { if (to.hash) { return { selector: to.hash } // return { x: 0, y: 200 }  } } // native JS element.scrollTo({ top: 100, left: 100, behavior: \u0026#39;smooth\u0026#39; }); // vue router 4 const router = new Router({ scrollBehavior(to, from, savedPosition) { // scroll to id `can~contain-special\u0026gt;characters` + 200px  return { el: \u0026#39;#can~contain-special\u0026gt;characters\u0026#39; // top relative offset  top: 200 // instead of `offset: { y: 200 }`  } } }) 更强大的 Devtools 多亏了新的Vue Devtools，Vue Router 能够和浏览器进行以下更高级的整合。\n 时间轴记录路由变化：   Timeline  完整 route 目录，能够帮助你轻松进行调试：   Routes directory   更好的路由守卫 beforeEach // BAD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) // 如果用户未能验证身份，则 `next` 会被调用两次  next() }) // GOOD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) else next() }) 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。 和next说拜拜，现在确认跳转不需要再手动执行这个函数了，而是根据你的返回值来决定行为。同样支持异步返回 Promise。\n现在的路由守卫 API 更加友好且合理了，可以完美利用 async await 做异步处理，比如这样：\nrouter.beforeEach(async (to, from) =\u0026gt; { // canUserAccess() returns `true` or `false`  return await canUserAccess(to) }) 路由独享的守卫 现在beforeEnter支持传入函数数组，便于复用，例如跳转到某个路由后自动去除所有query和hash\n// vue-router 3 const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, beforeEnter: (to, from, next) =\u0026gt; { // ...  } } ] }) // vue-router 4 function removeQueryParams(to) { if (Object.keys(to.query).length) return { path: to.path, query: {}, hash: to.hash } } function removeHash(to) { if (to.hash) return { path: to.path, query: to.query, hash: \u0026#39;\u0026#39; } } const routes = [ { path: \u0026#39;/users/:id\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams, removeHash], }, { path: \u0026#39;/about\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams], }, ] 迁移成本低 Vue Router 4 主要致力于于在改善现有 Router 的同时保持非常相似的 API，如果你已经很上手旧版的 Vue Router 了，那你的迁移会做的很顺利，可以查看文档中的完整迁移指南。\n展望未来 在过去的几个月中，Vue Router 一直稳定而且好用，现在它可以做些更好玩的事儿了：\n 使用现有工具（Vetur，Vite，Devtools 等）得到更好的开发体验。 与 Suspense 等现代功能更好地集成。 RFCs 和社区共同探讨出更好用的 API。 开发更轻型的版本。  Breaking Changes(partial) New history option to replace mode The mode: \u0026lsquo;history\u0026rsquo; option has been replaced with a more flexible one named history. Depending on which mode you were using, you will have to replace it with the appropriate function:\n \u0026ldquo;history\u0026rdquo;: createWebHistory() \u0026ldquo;hash\u0026rdquo;: createWebHashHistory() \u0026ldquo;abstract\u0026rdquo;: createMemoryHistory()  Here is a full snippet:\nimport { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; // there is also createWebHashHistory and createMemoryHistory  createRouter({ history: createWebHistory(\u0026#39;/base-directory/\u0026#39;), routes: [], }) Missing required params on named routes Pushing or resolving a named route without its required params will throw an error:\n// given the following route: const routes = [{ path: \u0026#39;/users/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: UserDetails }] // Missing the `id` param will fail router.push({ name: \u0026#39;user\u0026#39; }) router.resolve({ name: \u0026#39;user\u0026#39; }) 参考资料：\nVue Router 3.0 文档 Vue Router 4.0 release log\nVue Router 4.0 doc\nVue Router Migration Vue Router4 dynamic routing Routes' Matching Syntax router-scroll-position Path Ranker vue-router-next GitHub repo\n","date":"2020-12-13T19:23:26+08:00","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/vue-router-4.0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B/cover_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/vue-router-4.0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B/","title":"Vue Router 4.0特性简介"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://observerzq.github.io/ObzerverZQ.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/","title":""},{"content":"The Code Reviewer\u0026rsquo;s Guide\n 代码评审的标准  CR的主要目的就是确保公司的代码库的健壮性随着时间增强。所有的CR工具和过程都是为这一目标而设计的。为了达到这个目标，我们要平衡一系列的取舍。\n首先，开发者必须要能够在他们的任务上实现代码的优化。如果不提交优化的代码，代码库永远也不会改良。另外，评审者在CR时提出的问题过于刁钻，也会抑制开发者make improvements的想法。\n另一方面，确保每个CL的质量不会导致代码库健壮程度下降，是评审者的责任。这其实可能很棘手，因为代码库通常会随时间逐渐质量下降，尤其是在团队处于紧迫的时间限制下，他们会认为必须用最快的办法实现目标。\n除此之外，一个评审者要对他们评审的代码有ownership和责任感。他们要确保代码库保持一致性、可维护性，还有所有在\u0026quot;What to look for in a code review.\u0026ldquo;提到的东西。\n我们得出了如下的期待作为CR标准的准则：\n总体而言，如果一个CL提升了系统整体代码健壮程度，那么评审者应该approve这个CL，即使它不是完美的。\nIn general, reviewers should favor approving a CL once it is in a state where it definitely improves the overall code health of the system being worked on, even if the CL isn\u0026rsquo;t perfect.\n这是CR guidelines的最高优先级的原则。这其中当然有限制，例如，如果CL添加了评审者不想要存在于系统中的特性，即使代码设计良好，评审者也仍然可以否决这个CL。关键在于没有“完美”的代码 \u0026ldquo;perfect\u0026rdquo; code——只有更好的代码 better code。评审者不应要求作者润饰每一处细小的代码。相反，评审者应该平衡提升质量的需要和按他们提出的改动建议修改这两者的重要性。一个评审者应该追求的不是完美无暇，而是持续进步continuous improvement.\n一个提升项目代码可维护性、可读性、可理解性的CL不应该仅仅因为它不够完美而被拖延几天或几周。评审者可以自在地指出一些可以改进的东西，但如果那不是非常重要，可以加个前缀Nit，来让开发者知晓那是一个用于润饰的可忽略的点。\n注意：本文不支持必然会让代码健壮程度恶化的CL。唯一可能允许的情况的是面临emergency的时候。\n指导\nCR有一个重要的功能，那就是教给开发者一些关于开发语言、框架、整体软件设计原则等等的新知识。帮助开发者学习新的东西永远是OK的。分享知识本就是让系统代码健壮度随时间提升的一部分。只需要记住一个问题，如果你的评论是纯分享性的，不是帮助改善代码以贴合本文档所描述的标准的关键部分的，记得加个Nit的前缀，或者指明这个问题不是作者必须在这个CL中修复的。\n原则\nTechnical facts and data overrule opinions and personal preferences.技术事实、数据要优先于观点和个人偏好。\n关于风格，style guide 是绝对权威。任何不在style guide中的纯风格问题（空格等）是个人偏好问题。代码风格应该和style guide保持一致。如果某类代码在style guide中没有先例，就接受作者的代码风格。\nAspects of software design are almost never a pure style issue or just a personal preference. 软件设计的层面几乎从不是一个纯风格问题或个人偏好问题。这些层面是基于深层的准则，并且需要基于这些准则衡量，而不是简单地根据个人观点。有时一个逻辑、流程等的实现有多种有效方法，如果作者可以通过数据或基于扎实的工程原则表明几个方法都有效且效果相当，那么评审者应当接受作者的个人偏好。否则最终应该由软件设计的标准原则决定。\n如果没有其他适用的准则，只要不损害系统整体代码健壮程度，评审者可以要求作者和代码库中现有的代码写法保持一致，\n解决冲突\n在CR中如果遇到了任何冲突，第一步应当是开发者和评审者一起尝试根据本文档或 The CL Author\u0026rsquo;s Guide and this Reviewer Guide中其他文档的内容达成共识。\n如果达成共识很困难，评审者与作者可以进行面对面的会议或VC，而不是试图通过CR评论来解决冲突（如果你还是决定这么做，记得为了方便未来其他读者阅读，在CL里的一条评论中记录讨论结果）。\n如果那还是解决不了问题，最常用的方法是扩大影响。通常可以推广到更大的团队讨论，让一个TL加入，请教代码库的maintainer，或者请求工程经理的建议。不要因为评审者和开发者不能达成一致意见就把CL晾在那儿。\n在代码评审中要关注的内容  注意: 要记住，确认以下每一点时要把 代码评审的标准 考虑在内。\n设计\n在一个review中最重要的要cover的东西是CL的整体设计。关于设计的问题有：CL中的不同代码段的相互作用是否清晰明了？这个变动属于你的codebase还是一个库？这个CL能否和系统的剩余部分整合良好？现在是不是添加这个功能的好时候？等等。\n后端接口定义，及时和后端沟通需求实现流程、边界场景、兜底及容错方案等等\n尽量使用自定义组件：一些页面中自定义组件和template混杂，定位template对应的js逻辑和wxml需要耗费额外的时间\n通用组件设计CheckList 需要注意的一些细节\nurl的拼接和参数的获取，以及重定向的encode和decode相关\nES7、8、9等新API在各移动端的兼容性\n等等\u0026hellip;\u0026hellip;\n功能\n这个CL是否实现了开发者想要实现的东西？开发者的意图是否对这部分代码的“用户”有益？“用户”通常包括终端用户（当他们被这个变动影响时）还有开发者（他们未来会“使用”这部分代码）。\n大多数情况下，我们期待开发者对CL进行了足够好的测试因而能够在CR阶段正确运行。然而，作为评审者你仍然应该考虑边界case，寻找并发问题，试图像用户一样思考，并确保没有只通过阅读代码就能发现的bug。\n// ... module.exports = (state = defaultState, action) =\u0026gt; { initVeduxOpts(state); switch (action.type) { case USER_STORE: { // ...  return assign({}, _state, { [CONST.VEDUX_OPTS]: action.options, // good  }); } // ...  return assign({}, defaultState, { [CONST.VEDUX_OPTS]: { lazy: false }, // bad  }); // ...  } }; 另一个在CR中考虑功能性的重要阶段是CL中存在理论上可能导致死锁或竞争条件race condition的并行编程parallel programming的时候。这些issue很难只通过运行代码检测到，并且通常需要开发者和评审者来谨慎地认真考虑、想透，来确保上述问题不会发生。（注意这也是一个可能存在竞争条件或死锁时不使用并发模型的好理由——CR会变得困难，代码也可能难以理解） 。\n复杂度\n这个CL是否过于复杂？在这个CL的每一层确认这一点——个别代码行是否写得太复杂？函数太复杂？class太复杂？“太复杂”通常意味着“无法被代码读者快速理解”。它也可能意味着“开发者可能会在调用或修改这段代码时引入缺陷”。\n\u0026lt;!--预计送达--\u0026gt; \u0026lt;view class=\u0026#34;snd_desc\u0026#34; wx:if=\u0026#34;{{!self_delivery_area \u0026amp;\u0026amp; !!expected_arrival_time \u0026amp;\u0026amp; (statusData.order_status==4 || statusData.order_status==6)}}\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;clock-icon\u0026#34; src=\u0026#34;https://img.meituan.net/kangaroox/5224788c9376e9e43f6b32bf8c4dd2221805.jpg\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; {{expected_arrival_time}}{{status_operate_area.delivery_time ? \u0026#39;:\u0026#39; : \u0026#39;\u0026#39;}} \u0026lt;view class=\u0026#34;snd_desc_time\u0026#34;\u0026gt;{{status_operate_area.delivery_time ? status_operate_area.delivery_time : \u0026#39;\u0026#39;}}\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!--倒计时--\u0026gt; \u0026lt;view class=\u0026#34;snd_desc\u0026#34; wx:if=\u0026#34;{{status_operate_area.operator_time_type == 2 \u0026amp;\u0026amp; operator_countdown_time}}\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;clock-icon\u0026#34; src=\u0026#34;https://img.meituan.net/kangaroox/5224788c9376e9e43f6b32bf8c4dd2221805.jpg\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; {{status_operate_area.operator_tip}}: \u0026lt;view class=\u0026#34;snd_desc_time count_down_time\u0026#34;\u0026gt;{{operator_countdown_time}}\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 一个典型的复杂度问题是过度设计over-engineering。开发者让代码过于通用，或者添加系统当下并不需要的功能。评审者尤其应该警惕过度设计。鼓励开发者去解决他们需要立刻解决的问题，而不是开发者推测可能未来需要解决的问题。未来的问题应该在问题来临时解决，因为那时你能才看见它的所有方面。\n测试\n对改动要求合适的单元、集成或端对端测试。总的来说，CL中也要像生产环境的代码一样添加测试，除非这个CL是处理紧急问题emergency的。 确保CL里的tests是正确、科学且有用的。测试不会测试它们自身，我们也不会为测试代码写测试代码——开发者必须保证tests是有效的。\n代码有问题的时候，测试确实会运行失败吗？如果它们覆盖的代码之外的部分发生了变动，它们会生成错误的通过结果吗？每个test是否都做出了简单有用的断言？test之间是否合适地拆分？\n记住tests也是需要维护的代码。不要因为它们不是主包的一部分就不顾复杂度。\n命名\n开发者是否为一切变量、函数等东西挑选了好的命名？一个好的命名可能要够长来表明对应的东西是什么或者它要做什么，不够长的话可能会变得难以阅读。\n注释\n开发者是否用可以理解的表达写出了清晰的注释？是否所有的注释都是必要的？通常来说，当注释解释为什么一些代码存在，那么注释是有用的。注释不应该解释一些代码在做什么。如果代码本身不够清晰来解释它自身在做什么，那这样的代码应该要简化。有一些例外，例如正则表达式、复杂的算法等等，解释它们在做什么的注释是有益的。但大多数注释是提供代码本身不能囊括的信息的，例如一个决策背后的推理过程。\n看CL之前就存在的注释可能会有帮助。也许有一个TODO可以在这次CL被移除，有一个建议与这次变动相悖的注释，等等。注意，注释与class、module、fucntion的文档不同，应该表达某段代码的目的，应该如何使用这段代码，以及被使用时会如何表现。\n// good async loadHistoryStatus() { // 参与人无法查看历史状态 ==\u0026gt; 讲清楚了“为什么”  if (this.data.isPindanParticipant) { return; } // ... } // bad async loadOrderStatus(isHide, options = {}) { const result = isNormOrder ? await orderStatus({ order_view_id: view_id, }) : await orderPindanStatus({ //...  }); // 接口迁移兜底 ==\u0026gt; 注释含义不清晰  this.setStatusDefault(result); // ==\u0026gt; 函数命名模糊  // ... } 代码风格\n在谷歌，我们对所有主流语言都具有style guides, 甚至大部分的冷门语言。确保CL遵循这些原则。\n如果你想提升一些不在style guide中的点，对你的comment加个Nit前缀，让开发者知道你认为那是一个可以优化代码的非强制的部分，但不是必需的。不要基于个人的代码风格偏好阻塞CL的提交。\nCL的作者不应该把纯style变动和其他变动混合在一起。这会让查看CL中发生的变动变得困难，让merge和回滚操作更复杂，以及导致其他问题。例如，如果作者想格式化整个文件，就让他们把格式化的变动作为单个CL发送给你，之后发送另外的带有功能性变动的CL。\n文档\n如果一个CL改变了用户构建、测试、调用或发布代码的方式，要检查作者是否更新了相关的文档，包括READMEs、生成的参考文档等等。如果CL删除或废弃了代码，考虑文档是否也应该被删除。如果文档缺失，就向开发者索要对应的文档。\nPS: Pocket项目维护者，发布新版本后请留意CHANGELOG的更新。\n每一行代码\n查看你被指派评审的每一行代码。一些数据文件、生成文件，或大的数据结构，你可以一目十行，但不要匆匆瞥过一个手工写的class，function或者代码段之后假设里面的代码都是okay的。显然一些代码需要更小心的检验scrutiny——你必须对此做出决策，但你至少应该确保你理解所有代码在执行的功能。\n如果代码太难阅读，拖延了review的速度，你应该告知开发者这一点，在试图review之前等待他们解释、澄清。 在谷歌，我们雇佣优秀的软件工程师，而你是其中一员。如果你不能读懂某段代码，很可能其他开发者也不能。所以当你请求代码开发者解释代码时，你也在帮助未来的开发者去理解这段代码。\n如果你能读懂代码，但你认为自己不能胜任这次CR，就要确保CL的评审者中有一位能够胜任，尤其是对于复杂的issue，比如安全、并发、无障碍功能accessibility、国际化等等。\n背景/上下文\n从一个更大的范围去看CL往往是有帮助的。通常CR工具只会将变动代码周围的几行代码展示给你。有时你必须查看整个文件来确认这个变动逻辑上正确且有意义。例如，你可能看到只加了4行代码，但当你查看整个文件，你会看到这4行处于一个50行的方法里，那么可能需要把这个方法拆分为几个更小的方法了。\n从整个系统环境来看这个CL也很有帮助。这个CL提升了系统的代码健康度，还是让系统更复杂、更经不起测试？不要接受降低系统代码健康度的CL。大部分系统会在多个小变化不断叠加的过程中变得更加复杂，因此避免因为新变动导致复杂度的小幅上升也很重要。\n好的东西\n如果你发现CL中有亮点，那就告诉开发者，尤其是当他们很好地处理了你的评论的时候。CR通常只专注在错误上，但它们也应该对好的实践表达鼓励和欣赏。在mentor的方面，有时告诉一个开发者他有什么地方做得好比告诉他什么地方做错了更有价值。\n总结\n在CR过程中，你应该确保:\nThe code is well-designed. 代码设计良好\nThe functionality is good for the users of the code. 功能对代码的用户友好\nAny UI changes are sensible and look good. UI变动是合理的并且看上去良好\nAny parallel programming is done safely. 所有并行编程都是安全地完成的\nThe code isn\u0026rsquo;t more complex than it needs to be. 代码不过度复杂\nThe developer isn\u0026rsquo;t implementing things they might need in the future but don\u0026rsquo;t know they need now. 开发者没有在实现他们未来可能需要而现在不需要的东西\nCode has appropriate unit tests. 代码有适当的单测\nTests are well-designed. 测试设计良好\nThe developer used clear names for everything. 开发者对变量、类、函数等命名清晰\nComments are clear and useful, and mostly explain why instead of what. 注释清晰有意义，主要解释why而不是what\nCode is appropriately documented (generally in g3doc). 代码被适当地记录在相关文档\nThe code conforms to our style guides. 代码遵循style guide\nMake sure to review every line of code you\u0026rsquo;ve been asked to review, look at the context, make sure you\u0026rsquo;re improving code health, and compliment developers on good things that they do.\n在评审中检阅变动的方式Navigating a CL in Review  总览\n现在你知道要在代码评审中检查什么问题 what to look for，那么对于横跨多个文件的CL，最高效的执行评审的方式是什么呢？\n这个变动说得通吗?有好的描述description吗?\n先看变动中最重要的部分。它是否有良好的设计？\n以恰当的顺序去看其余部分。\n第一步：纵观整体改动\n查看CL描述CL description 和CL执行的总体工作。如果这个变动一开始就不应该发生，请立即回应并解释为什么这个变动不应该发生。拒绝这样的变动的同时，不妨给开发者提供另外的处理方案的建议。\n例如，你可以说 \u0026ldquo;Looks like you put some good work into this, thanks! However, we\u0026rsquo;re actually going in the direction of removing the FooWidget system that you\u0026rsquo;re modifying here, and so we don\u0026rsquo;t want to make any new modifications to it right now. How about instead you refactor our new BarWidget class?\u0026rdquo;\n注意，这里评审者不止拒绝了这个CL、提供替代方案建议，还做到了礼貌的回应。这种礼仪很重要，因为我们想在即使反对代码时也表明对开发者的尊重。\n如果你收到了很多不理想的变动的CL，你应该考虑重新处理你的团队的开发流程或外部贡献者的现有流程，这样在CL被书写前能有更多的沟通。最好在人们写了一通代码最后不得不全部废弃或者哗啦啦重写之前跟他们say no。\n第二步Step Two: 检验CL的主体部分\n找出CL的主要部分的文件。一般而言，如果有一个文件中有大量的逻辑改动，那么那个文件就是CL的主体部分。一定要先看这些部分。这有助于了解CL中其他小的部分的背景，同时也能加快做代码评审的速度。如果CL太大，你无法得知哪些是主体部分，询问开发者应该先看哪一块，或者让他们拆分CL。\n如果你在CL这一部分看到了重大设计问题，即使没时间看剩余的部分也应该立即发出评论。其实，审阅其余部分可能是浪费时间，因为如果设计问题很严重的话，其余的代码无论如何都是要消失掉的。\n要立即发出评论的主要原因有以下两个:\n开发者通常会在发出CL审阅邀请等待后立刻开始基于该CL的新的工作。如果你审阅的CL中有重大设计问题，那意味着他们后面的CL也要重新改造。所以最好在他们在那个问题设计之上做太多无用功之前抛出问题。\n重大设计改造比小改动要花更长的时间。开发者大多有deadline，为了让赶上ddl同时保持代码质量，开发者需要尽快开始CL中大型的重写。\n第三步：以合适的顺序浏览CL的剩余部分\n一旦确认了CL中没有严重的设计问题之后，尝试理清楚浏览文件的逻辑顺序，同时也确保你没有遗漏任何文件的审阅。查看了最重要的文件后，通常最简单的方式就是按照代码评审工具展示给你的顺序去浏览其他文件。有时阅读主要代码之前先阅读测试代码也有帮助，因为这样你就有了这个变动需要实现的功能的大致概念。\n代码评审的速度  代码评审为什么要快？\n代码评审者的CR速度过慢的话，以下事情会发生:\n团队整体的速度下降。受邀者不快速回应审阅邀请，个人而言确实完成了其他的工作。然而，团队中其余成员的新的feature和bug fix会被拖延了数天甚至上周，因为每个CL需要评审和再评审。\n开发者开始反对代码评审流程。如果一个评审者只是每隔几天才回应，但每次都要求大的改动，那会让开发者感到沮丧和困难。通常，他们会抱怨评审者有多“严格”。 如果评审者要求同样的重大改动（改动确实提升代码质量）但是每次开发者更新后都反应快速，抱怨往往会消失。大多数关于代码评审流程的抱怨实际上是通过提升流程的速度解决的。\n代码健康度会受到影响。评审速度慢下来，给开发者的压力就增加了，他们会提交不那么好的代码。过慢评审也会抑制代码清洁、重构和对已有CL的进一步优化。\n代码评审应该要多快？\n如果你不是在全神贯注地执行某项任务，你应该在收到评审邀请后尽快进行代码评审。\n处理代码评审邀请的最长反应时间是一个工作日，也就是最晚作为第二天早上的第一件事来处理。\n遵循这些守则意味着一个典型的CL应该会在一天之内进行多轮的代码评审。\n速度vs打断\n个人速度和团队速度存在一个平衡取舍。如果你在进行编写代码等需要集中注意力的任务，不要中断去做代码评审。研究显示开发者在被打断后需要花费更多时间用于回到顺畅的开发工作。\n在处理评审邀请前，等待工作中的一个休息点。可以是当前的编码工作完成时，或者是午饭后，从会议室、餐厅等地方回到工位时，等等。\n快速反应\n当我们谈论代码评审的速度, 我们关心的是反应时间，而不是一个CL经历整个代码评审流程之后被提交的耗时。 对于代码评审的邀请的快速反应比整个代码评审过程快速完成更重要。\n即使整个评审过程需要很长时间，评审者在这个过程中的快速反应也可以显著地减轻开发者因为漫长的代码评审等待带来的挫败感。\n如果收到了一个CL评审邀请，而你过于忙碌以至于无法进行全面的代码评审，你依然可以快速回复，让开发者知道你会去着手这件事情，或者请求其他有更宽裕时间的评审者进行评审，或者提供一些广泛范围的评论 provide some initial broad comments。(Note: none of this means you should interrupt coding even to send a response like this—send the response at a reasonable break point in your work.)\n评审者花费足够的时间确认他们在评审结果给的“LGTM”tag意味着“这段代码符合我们的标准”是很重要的。 无论如何，反馈依然应该保持快速。\n带有评论的LGTM\n为了提升代码评审过程的速度，在以下情况，即使代码评审者在CL中留下了未解决的评论，他们也应当给出 LGTM/Approval:\n评审者对开发者回适当地解决所有遗留评论中提出地问题有充足地自信。\n遗留的问题都是细微的，不需要由开发者完成。\n如果评审者先前没有说明，他们应当明确指出自己更倾向以上的哪些选项。在开发者和评审者处于不同时区时，这种处理尤其值得考虑。\n大型CL\n如果有人让你审阅一个改动相当大范围的CL，而且你不确定自己是否有充足的时间去评审，一般而言可以要求开发者把CL拆分成更小的互相依赖的CL split the CL into several smaller CLs 。\n如果一个CL无法被拆分成更小的CL，同时你也没有时间去快速评审整个CL，那么至少写一些关于CL的整体设计的评论，发给开发者用于改进。作为评审者你的目标之一是在不损害代码健康度的情况下，推动他们去快速地进行一些进一步的改善。\n代码评审的逐渐进步\n如果你遵循这些指导并且对代码评审保持严格，你会发现整个代码评审流程的速度逐渐提升。开发者学习到健康代码的要点，给你提交的CL一开始就有了高质量，因而需要的评审时间也越来越短。评审者学习到快速反应，不给评审过程增添不必要的延迟时间。但是不要为了臆想的速度提升在代码评审标准code review standards或质量上妥协—长远来看这不会让任何事情完成得更快。\n紧急情况下代码评审必须尽快完成，那么评审的标准就可以相对放松。不过请浏览 What Is An Emergency? 来确认符合紧急情况的情景。\n How to Write Code Review Comments\n  Handling Pushback in Code Reviews\n  The Change Author\u0026rsquo;s Guide\n Writing Good CL Descriptions  一个CL描述是一篇关于变动是什么和为什么做出变动的公开记录。它会成为我们的版本控制历史的永久性的一部分，随着时间流逝，还可能会被除了你的评审者之外的上百人阅读。\n未来的开发者会根据CL描述来搜寻你的CL。有需要的人不必记住具体细节，只需凭借模糊的相关记忆就能很方便地找到你的CL。而如果所有重要信息都在代码里而不在description里，定位到你的CL会变得困难很多。\n首行\nShort summary of what is being done. 所完成的事情的简短概述\nComplete sentence, written as though it was an order. 完整的句子，像命令一样书写\nFollow by empty line. 接下来是空白行\nCL描述的首行应该针对CL做了什么做一个简短的概述，下面带一行空白行。这是大部分未来代码查阅者会在浏览一段代码的版本控制历史时所看到的。所以第一行必须要有足够的信息量，让读者不需要去阅读你的代码细节或者是整个CL描述来得知你的CL所做的事情。\n传统上，CL描述的第一行是一个完整的句子，像命令（祈使句）一样写下。例如， \u0026ldquo;Delete the FizzBuzz RPC and replace it with the new system.\u0026rdquo; 而不是\u0026quot;Deleting the FizzBuzz RPC and replacing it with the new system.\u0026rdquo; 不过你不需要在描述的其余部分也写成这样的祈使句。\n正文包含有效信息\n描述的其余部分应该提供有用的信息。可以包含关于正在解决的问题的简短描述，以及为什么这个CL中的解决方案是最佳的。如果这个方案有任何缺点，那么作者应该在描述中提及这些缺点。除此之外，还可以包含背景信息，例如bug数量，基准衡量结果，以及技术设计文档的链接等相关信息。\n如果你放置了外部资源的链接，而未来的读者可能由于访问限制不能获取到这些资源，那么要尽可能提供充分的背景信息来让评审者和未来的读者来理解这个CL。\n即使是细微的CL也需要关注到细节。\n糟糕的CL描述\n\u0026ldquo;Fix bug\u0026quot;是一个不充分的CL描述。什么bug？你做了什么来修复它？其他的问题描述包括：\n\u0026ldquo;Fix build.\u0026rdquo;\n\u0026ldquo;Add patch.\u0026rdquo;\n\u0026ldquo;Moving code from A to B.\u0026rdquo;\n\u0026ldquo;Phase 1.\u0026rdquo;\n\u0026ldquo;Add convenience functions.\u0026rdquo;\n\u0026ldquo;kill weird URLs.\u0026rdquo;\n以上有一部分是真实存在的CL描述。这些描述的作者认为他们提供了有用的信息，但事实上这些并不符合CL描述的要求和目标。\n良好的CL描述\n下面是一些高质量的CL描述的例子。\n功能变化\n例子:\n rpc: remove size limit on RPC server message freelist.\nServers like FizzBuzz have very large messages and would benefit from reuse. Make the freelist larger, and add a goroutine that frees the freelist entries slowly over time, so that idle servers eventually release all freelist entries.\n 第一行描述CL做了些什么。其余部分讲解解决的问题，以及为什么这是一个好的解决方案，还有部分关于具体实现的信息。\n重构\n例子:\n Construct a Task with a TimeKeeper to use its TimeStr and Now methods. Add a Now method to Task, so the borglet() getter method can be removed (which was only used by OOMCandidate to call borglet\u0026rsquo;s Now method). This replaces the methods on Borglet that delegate to a TimeKeeper.\nAllowing Tasks to supply Now is a step toward eliminating the dependency on Borglet. Eventually, collaborators that depend on getting Now from the Task should be changed to use a TimeKeeper directly, but this has been an accommodation to refactoring in small steps.\nContinuing the long-range goal of refactoring the Borglet.\n 第一行描述CL做了些什么以及相对过去而言发生了什么变化。其余部分讲解具体的实现，CL的补充信息——这次解决方式不够理想，以及未来可能的改进方向。这个CL也解释了这个变动的原因。\n需要一些背景信息的小的CL\n例子:\n Create a Python3 build rule for status.py.\nThis allows consumers who are already using this as in Python3 to depend on a rule that is next to the original status build rule instead of somewhere in their own tree. It encourages new consumers to use Python3 if they can, instead of Python2, and significantly simplifies some automated build file refactoring tools being worked on currently.\n 第一行描述了这个CL做了些什么。其余部分解释了这个变动的原因，并且提供很多背景信息给评审者。\n在提交CL之前回顾CL描述\n评审期间CL可能发生重大的变化。在提交CL之前，回顾一下CL描述，以确保描述依然准确反映CL所完成的工作，是非常值得的。\nSmall CLs  为什么要写小的CL？\n小的，简单的CL有以下优点：\n更快速地完成评审. It\u0026rsquo;s easier for a reviewer to find five minutes several times to review small CLs than to set aside a 30 minute block to review one large CL.\n更透彻地完成评审. With large changes, reviewers and authors tend to get frustrated by large volumes of detailed commentary shifting back and forth—sometimes to the point where important points get missed or dropped.\n降低引入缺陷的可能性. Since you\u0026rsquo;re making fewer changes, it\u0026rsquo;s easier for you and your reviewer to reason effectively about the impact of the CL and see if a bug has been introduced.\n如果被否决不会做太多无用功。If you write a huge CL and then your reviewer says that the overall direction is wrong, you\u0026rsquo;ve wasted a lot of work.\n更容易合并。Working on a large CL takes a long time, so you will have lots of conflicts when you merge, and you will have to merge frequently.\n更容易设计良好。It\u0026rsquo;s a lot easier to polish the design and code health of a small change than it is to refine all the details of a large change.\n在评审过程中更不容易被阻塞挂起. Sending self-contained portions of your overall change allows you to continue coding while you wait for your current CL in review.\n更容易回滚。A large CL will more likely touch files that get updated between the initial CL submission and a rollback CL, complicating the rollback (the intermediate CLs will probably need to be rolled back too).\n注意评审者有仅因CL太大而直接拒绝你的CL的决定权。已经写好之后再拆分一个change会花费很大工作量，或者浪费很多时间争取让评审者接收你的大的cl。 一开始就写小的CL会更方便。\n什么是“小”的CL？\n总的来说，一个小的CL是one self-contained change. 这意味着:\nCL只改动了一个东西just one thing. 这通常是feature的一部分，而不是一次过新增整个feature。和你的评审者一起调研合适的CL大小。\n评审者理解这个CL所需要的所有东西都在CL中 (除了未来的开发) ，包括CL描述，现有的codebase，或者是他们已经评审过的CL。\nCL合并之后系统会继续面向用户和开发者运行良好。\nCL不至于太小以至于它的影响很难理解。如果你添加了一个新的API，你应该在CL中包含这个API的用法，这样评审者能更好理解API会如何使用。这也避免合入了没有用到的API。\n“太大”并没有一个严格的规定。100行通常是合理的，1000行通常太大，但最终还是基于你的评审者的判断。CL涉及的文件数量也影响CL的“大小”。一个文件中的200行或许ok，但是横跨50个文件就显得太大了。\n记住即使你从一开始写代码时就紧密参与其中，评审者通常不知晓上下文背景。看起来可以接受的CL规模可能对评审者来说难以接受。如果存疑，写比你认为必要的更小的CL。评审者几乎不埋怨CL太小。\n大型 CLs 什么时候是OK的？\n整个文件的删除可以看成是一行代码变动，因为那不会耗费评审者太长时间。\n有时一个大的CL是由你完全信任的自动化重构工具生成的，那么评审者的工作就是sanity check，然后说他们确实想要那个改动。即使有上面的告诫（例如合并和测试），这些CL可以更大。\n根据文件集拆分\n另一个拆分CL的方法是把需要不同评审者的文件分组。\n例如：你发出了一个修改协议buffer的CL，和一个使用那个协议的代码的CL。你必须在提交代码相关的CL之前先提交修改proto的CL，但他们可以同时被审阅。如果这样做，你可能需要将另一个CL的改动通知到两边的评审者，以让他们了解改动的上下文和背景。\n又例如：你你提交了代码改动的CL，另一个是使用了那段代码的配置或实验。如果必要话，这种也很容易回滚，因为配置/实验文件被推送到生产环境的速度比代码改动更快。\n把重构代码分隔到另一个CL\n通常把重构放在与新增特性、缺陷修复等分开的新的CL里是最好的做法。例如，把移动、重命名一个类和修复这个类中的一个bug放在不同的CL里。这让评审者更易于理解每个CL中的变动。\n小的改动，例如修改一个本地变量名可以放在新增特性或缺陷修复的CL中。这取决于开发者和评审者对重构包含在同一个CL中是否会让评审变得困难的判断。\n将测试代码保留在同一个CL中\n避免把测试代码拆分到另外的CL中。即使增加了代码行，也应该把验证你的代码改动的代码放在同一个CL中。\n然而，独立的测试修改代码可以先放到另外的CL中，类似重构指导 refactorings guidelines.。那包括：\n用新的测试验证之前存在的提交过的代码\n重构测试代码 (例如引入helper方法)\n引入更大的测试框架代码（例如集成测试）\n不要破坏构建\n如果你有几个互相依赖的CL，你需要找到方法，确保整个系统在每个CL提交后都保持正常运行。否则你可能会在多个CL提交的期间，甚至因为后面的CL提交出现问题导致更长的时间里破坏面向整个团队的项目的构建。\n无法让CL变得足够小?\n有时你会遇到CL只能很大的情况——然而这其实并不是对的。实践、练习写小规模CL的作者总是可以找到将功能分解成一系列小的CL的方法。\n在写一个大的CL之前，考虑。 和你的同事谈谈，有没有能用小的CL实现功能的方法。Before writing a large CL, consider whether preceding it with a refactoring-only CL could pave the way for a cleaner implementation.\n如果这些选项都走不通（这种情况很罕见），那么在提交评审前，先取得你的评审者的同意，让他们心中有数。在这种情况下，做好经历长时间review的准备，小心不要引入bug，勤快点测试。\nWANT_LGTM to clarify the expectation when a CL is sent to multiple reviewers. You can use WANT_LGTM=any (the default behavior) or WANT_LGTM=all to clarify.\nHow to Handle Reviewer Comments\n原文地址：Google Engineering Practices Documentation\n扩展阅读：Google Style Guides\nhttps://github.com/google/eng-practices/blob/master/review/developer/small-cls.md\nhttps://github.com/google/eng-practices/blob/master/review/emergencies.md\nhttps://www.michaelagreiler.com/wp-content/uploads/2019/09/Code-Review-E-Book-Greiler-V2.pdf\n","date":"0001-01-01T00:00:00Z","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/","title":""},{"content":"一周多以前，vue-router团队正式发布了适配Vue 3的vue-router4.0版本。本文将结合4.0版本的release log对该版本的部分新特性进行介绍。\n 项目结构优化  Vue Router 现在分为三个模块：* History 实现： 处理地址栏，并且特定于 Vue Router 运行的环境（节点，浏览器，移动设备等）\n  Router Matcher：处理类似 /users/:id 的路由解析和优先级处理。\n  Router: 将一切连接在一起，并处理路由特定功能，例如导航守卫。\n  |____types // 全局通用type | |____typeGuards.ts // 对route进行校验 | |____index.ts // type和interface |____router.ts // connects everything together and handle routing specific features like navigation guards |____RouterLink.ts |____errors.ts |____globalExtensions.ts |____injectionSymbols.ts |____utils | |____callbacks.ts | |____README.md | |____index.ts | |____env.ts |____devtools.ts |____location.ts |____matcher // handles the parsing of routes /users/:id and its ranking | |____pathTokenizer.ts // path解析器，生成token数组tokenizePath | |____pathMatcher.ts // 提供createRouteRecordMatcher方法供index调用，在addRoute时创建matcher | |____pathParserRanker.ts // 对每一个setment计算score | |____types.ts // 定义RouteRecordNormalized作为RouteRecord | |____index.ts // 定义并实现RouterMatcher，内部定义matcherMap路由映射；对RouteRecord、RouteProps进行normalize |____warning.ts |____RouterView.ts |____scrollBehavior.ts |____history // 处理地址栏相关动作和API，适配不同环境(Node, Browser, Mobile, etc) | |____common.ts // 列举一些通用的用于History API的interface、type、enum和在两个模式下通用的方法 | |____hash.ts // hash模式，createWebHashHistory | |____html5.ts // html5模式，createWebHistory | |____memory.ts // abstract模式，createMemoryHistory, 记录路由队列、监听器和当前位置，实现router方法。如果发现没有浏览器的 API，路由会自动强制进入这个模式 |____global.d.ts // // Global compile-time constants |____useApi.ts |____index.ts |____query.ts |____encoding.ts |____navigationGuards.ts // 路由守卫 动态路由匹配  vue-router 3使用 [path-to-regexp]作为路径匹配引擎。有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。当使用通配符路由时，必须确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: \u0026lsquo;*\u0026rsquo; } 通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。\n{ // 会匹配所有路径 path: \u0026#39;*\u0026#39; } { // 会匹配以 `/user-` 开头的任意路径 path: \u0026#39;/user-*\u0026#39; } Vue Router 4不再使用path-to-regexp，而是使用自己的转化系统。新增了有自动优先级排名的高级路径解析功能，用户新现在可以以随意的顺序定义路由，因为 Router 会根据 URL 字符串表示来猜测应该匹配的路由。举个例子来说，你同时写了 /users 和 /:w+ 这两个路由：\nconst routes = [ { path: \u0026#39;/users\u0026#39;, Component: Users }, { path: \u0026#39;/:w+\u0026#39;, Component: NotFound }] 那么你当然希望在输入 /users 这个更精确的路径的时候，走上面的规则，而下面则作为兜底规则。在旧版的 Vue Router 中需要通过路由声明的顺序来保证这个行为，而新版则无论你怎样放置，都会按照得分系统来计算该匹配哪个路由。\n用于匹配路由的一些数据结构：\nexport interface RouteRecordMatcher extends PathParser { record: RouteRecord parent: RouteRecordMatcher | undefined children: RouteRecordMatcher[] // aliases that must be removed when removing this record  alias: RouteRecordMatcher[] } export const enum TokenType { Static, Param, Group, } // Scoring values used in tokensToParser const enum PathScore { _multiplier = 10, Root = 9 * _multiplier, // just /  Segment = 4 * _multiplier, // /a-segment  SubSegment = 3 * _multiplier, // /multiple-:things-in-one-:segment  Static = 4 * _multiplier, // /static  Dynamic = 2 * _multiplier, // /:someId  BonusCustomRegExp = 1 * _multiplier, // /:someId(\\\\d+)  BonusWildcard = -4 * _multiplier - BonusCustomRegExp, // /:namedWildcard(.*) we remove the bonus added by the custom regexp  BonusRepeatable = -2 * _multiplier, // /:w+ or /:w*  BonusOptional = -0.8 * _multiplier, // /:w? or /:w*  // these two have to be under 0.1 so a strict /:page is still lower than /:a-:b  BonusStrict = 0.07 * _multiplier, // when options strict: true is passed, as the regex omits \\/?  BonusCaseSensitive = 0.025 * _multiplier, // when options strict: true is passed, as the regex omits \\/? } 代码大致路径如下：\n// project router/index.js const routes = [ // will match everything and put it under `$route.params.pathMatch`  { path: \u0026#39;/:pathMatch(.*)*\u0026#39;, name: \u0026#39;NotFound\u0026#39;, component: NotFound }, { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home, children: [ { path: \u0026#39;pending\u0026#39;, name: \u0026#39;pendingCase\u0026#39;, meta: { title: \u0026#39;待我处理\u0026#39; } }, ], }, { path: \u0026#39;/about/:id\u0026#39;, name: \u0026#39;About\u0026#39;, // route level code-splitting  // this generates a separate chunk (about.[hash].js) for this route  // which is lazy-loaded when the route is visited.  component: () =\u0026gt; import(/* webpackChunkName: \u0026#34;about\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;), beforeEnter: [removeQueryParams, removeHash], }, ]; const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes, }); // vue-router // src/router.ts export function createRouter(options: RouterOptions): Router { const matcher = createRouterMatcher(options.routes, options) ... } // src/matcher/index.ts export function createRouterMatcher( routes: RouteRecordRaw[], globalOptions: PathParserOptions ): RouterMatcher { // normalized ordered array of matchers  const matchers: RouteRecordMatcher[] = [] const matcherMap = new Map\u0026lt;RouteRecordName, RouteRecordMatcher\u0026gt;() // 路由映射  // strict，默认为false，为false时末尾增加/符号  // end，默认为true，即正则表达式末尾会增加 $ 符号  // sensitive 若为false则会忽略大小写，默认为false  globalOptions = mergeOptions( { strict: false, end: true, sensitive: false } as PathParserOptions, globalOptions ) function getRecordMatcher(name: RouteRecordName) { return matcherMap.get(name) } function addRoute( record: RouteRecordRaw, parent?: RouteRecordMatcher, originalRecord?: RouteRecordMatcher ){ // ...  // create the object before hand so it can be passed to children  matcher = createRouteRecordMatcher(normalizedRecord, parent, options) // ...  // alias设置  // 检查children字段，如存在则遍历调用addRoute  // 在路由映射中插入该matcher，应用分数高低进行排序插入  insertMatcher(matcher) } function removeRoute(matcherRef: RouteRecordName | RouteRecordMatcher) {} function getRoutes() { return matchers } function insertMatcher(matcher: RouteRecordMatcher) {} function resolve(){} // add initial routes, each as a RouteRecord  routes.forEach(route =\u0026gt; addRoute(route)) return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher } } // src/matcher/pathMatcher.ts export function createRouteRecordMatcher( record: Readonly\u0026lt;RouteRecord\u0026gt;, parent: RouteRecordMatcher | undefined, options?: PathParserOptions ): RouteRecordMatcher { const parser = tokensToParser(tokenizePath(record.path), options) // ...  } // src/matcher/pathParserRanker.ts 语法分析  export function tokensToParser( segments: Array\u0026lt;Token[]\u0026gt;, extraOptions?: _PathParserOptions ): PathParser { // 对token数组进行逐个分数计算 } // src/matcher/pathTokenizer.ts 词法分析 export function tokenizePath(path: string): Array\u0026lt;Token[]\u0026gt; {} 甚至专门有 [Path Ranker]这个网页来帮助你计算路由的优先级得分。简单来说，越明确的路由排名越高，越模糊则反之，无关顺序。 3. 改进后的导航系统\n新的导航系统更加具有一致性，它改善了滚动行为的体验，使其更加接近原生浏览器的行为。 它还为用户提供了有关导航状态的几乎更多信息，用户可以用这些信息，通过 ProgressBar和 Modal之类的全局 UI 元素让用户的体验变得更好。\nconst router = createRouter({ history: createWebHashHistory(), routes: [...], scrollBehavior (to, from, savedPosition) { // return desired position  } }) 改进动机：\n 先前的selector默认使用document.querySelector。但是这个API不支持 /^#\\d/即以数字开头的id元素，所以vue3团队决定针对这种参数使用getElementById。但是这个API仍不适用于选择某个id元素内的某个class的元素，比如#1one .container。诸如此类的情况都会导致vue-router抛出document.querySelector failed，让用户产生困惑。  { x: number, y: number } { selector: string, offset? : { x: number, y: number }} 基于Element.scrollTo的参数配置ScrollToOptions，vue-router 4进行了改造  // vue router 3 scrollBehavior (to, from, savedPosition) { if (to.hash) { return { selector: to.hash } // return { x: 0, y: 200 }  } } // native JS element.scrollTo({ top: 100, left: 100, behavior: \u0026#39;smooth\u0026#39; }); // vue router 4 const router = new Router({ scrollBehavior(to, from, savedPosition) { // scroll to id `can~contain-special\u0026gt;characters` + 200px  return { el: \u0026#39;#can~contain-special\u0026gt;characters\u0026#39; // top relative offset  top: 200 // instead of `offset: { y: 200 }`  } } }) 更强大的 Devtools  新的[Vue Devtools]，让Vue Router 能够和浏览器进行以下更高级的整合。1. 时间轴记录路由变化： 2. 完整 route 目录，能够帮助你轻松进行调试： 5. 更好的路由守卫\nbeforeEach\n在Vue-router3 中\n// BAD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) // 如果用户未能验证身份，则 `next` 会被调用两次 next()}) )} // GOOD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) else next() }) `确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。\nVue-router4则和next说拜拜，现在确认跳转不需要再手动执行这个函数了，而是根据你的返回值来决定行为。同样支持异步返回 Promise。现在的路由守卫 API 更加友好且合理了，可以完美利用 async await 做异步处理，比如这样：\nrouter.beforeEach(async (to, from) =\u0026gt; { // canUserAccess() returns `true` or `false`  return await canUserAccess(to) }) 路由独享的守卫\n现在beforeEnter支持传入函数数组，便于复用，例如跳转到某个路由后自动去除所有query和hash\n// vue-router 3 const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, beforeEnter: (to, from, next) =\u0026gt; { // ...  } } ] }) // vue-router 4 function removeQueryParams(to) { if (Object.keys(to.query).length) return { path: to.path, query: {}, hash: to.hash } } function removeHash(to) { if (to.hash) return { path: to.path, query: to.query, hash: \u0026#39;\u0026#39; } } const routes = [ { path: \u0026#39;/users/:id\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams, removeHash], }, { path: \u0026#39;/about\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams], }, ] 迁移成本低  Vue Router 4 主要致力于于在改善现有 Router 的同时保持非常相似的 API，如果你已经很上手旧版的 Vue Router 了，那你的迁移会做的很顺利，可以查看文档中的完整迁移指南。\n展望未来  在过去的几个月中，Vue Router 一直稳定而且好用，现在它可以做些更好玩的事儿了：* 使用现有工具（Vetur，Vite，Devtools 等）得到更好的开发体验。\n  与 Suspense 等现代功能更好地集成。\n  RFCs 和社区共同探讨出更好用的 API。\n  开发更轻型的版本。\n  Breaking Changes(partial)\nhttps://next.router.vuejs.org/guide/migration/index.html#breaking-changes\nNew history option to replace mode\nThe mode: \u0026lsquo;history\u0026rsquo; option has been replaced with a more flexible one named history. Depending on which mode you were using, you will have to replace it with the appropriate function:* \u0026ldquo;history\u0026rdquo;: createWebHistory()\n  \u0026ldquo;hash\u0026rdquo;: createWebHashHistory()\n  \u0026ldquo;abstract\u0026rdquo;: createMemoryHistory()\n  import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; // there is also createWebHashHistory and createMemoryHistory  createRouter({ history: createWebHistory(\u0026#39;/base-directory/\u0026#39;), routes: [], }) Missing required params on named routes\nPushing or resolving a named route without its required params will throw an error:\n// given the following route: const routes = [{ path: \u0026#39;/users/:id\u0026#39;, name: \u0026#39;user\u0026#39;, component: UserDetails }] // Missing the `id` param will fail router.push({ name: \u0026#39;user\u0026#39; }) router.resolve({ name: \u0026#39;user\u0026#39; }) 参考资料\nVue Router 3.0 文档\nVue Router 4.0 release log\nVue Router 4.0 doc\nVue Router Migration\nVue Router4 dynamic routing\nRoutes' Matching Syntax\nrouter-scroll-position\nPath Ranker\nvue-router-next GitHub repo\n","date":"0001-01-01T00:00:00Z","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/","title":""},{"content":"小程序渲染原理 所有页面都可以抽象成一棵节点树，每个节点具有自身的属性，包括样式、事件等等。\n一般的H5页面：HTML + CSS + JavaScript\n小程序：WXML + WXSS + JavaScript 技术选型 目前来说，移动端页面渲染的方式主要有三种：\n  Web 渲染。\n  Native 原生渲染。\n  Web 与 Native 两者掺杂，也即我们常说的 Hybrid 渲染。\n  前面也说过，小程序最终的呈现形式，是 WebView + 原生组件，Hybrid 方式。我们结合之前对小程序的期望来看：\n 开发门槛：Web 门槛低，不过 Native 也有像 RN 这样的框架支持\n体验：Native 体验比 Web 好，Hybrid 在一定程度上比 Web 接近原生体验\n版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布\n管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险\n 由于小程序的宿主是微信，如果用纯客户端原生技术来编写小程序 ，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。所以方向应该是需要像 Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。\n如果用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题。这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。\n总地看来，小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：\n   扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力\n  体验更好，同时也减轻 WebView 的渲染工作\n  绕过 setData、数据通信和重渲染流程，使渲染性能更好\n   现在，我们还剩下一个很重要的问题：管控性和安全性。为了解决这些问题，我们需要阻止开发者使用一些浏览器提供的，诸如跳转页面、操作 DOM、动态执行脚本的开放性接口。于是，双线程的设计被提出来了。\n在浏览器里，UI 渲染和 JavaScript 逻辑都是在一个线程中执行的。在同一个线程中，UI 渲染和 JavaScript 逻辑交替执行，JavaScript 也可以通过 DOM 接口来对渲染进行控制。\n小程序使用的是一种两个线程并行执行的模式，叫做双线程模型，两个线程合力完成小程序的渲染，一个线程专门负责使用WebView渲染工作，我们一般称之为渲染层；而另外有一个线程采用JsCore线程运行JS脚本执行我们的逻辑代码，我们一般叫做逻辑层。一个小程序存在多个界面，所以渲染层存在多个WebView线程，一方面，对于用户来说更加有页面的感觉，体验更好，而且也可以避免单个 WebView 的负担太重；另一方面，将小程序代码运行在独立的线程中的模式有更好的安全表现，允许有像 open-data 这样的组件可以在确保用户隐私的前提下让我们展示用户数据。这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。这两个线程同时运行，并通过微信客户端来交换数据： 界面的渲染和后台的逻辑处理可以在同一时间运行了，这使得小程序整体的响应速度更快了。而在小程序的运行过程中，逻辑层需要常驻，但渲染层是可以回收的。实际上，当页面栈的层数比较高的时候，栈底页面的渲染层是会被慢慢回收的。\n双线程通信 把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。那要怎么去实现动态更改界面呢？\n前面我们知道，逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。这是不是意味着，我们可以把 DOM 的更新通过简单的数据通信来实现呢？\nVirtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -\u0026gt; 比较两棵虚拟DOM树的差异 -\u0026gt; 把差异应用到真正的DOM树上。\nWXML结构实际上等价于一棵Dom树，通过一个JS对象也可以来表达Dom树的结构 WXML可以先转成JS对象，然后再渲染出真正的Dom树 通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理。\n在这里我们可以用上，如图：    在渲染层把 WXML 转化成对应的 JS 对象。\n  在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。\n  经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。\n   我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。而这样完整的一套框架，基本上都是通过小程序的基础库来完成的。 在小程序运行的时候，逻辑层执行我们编写的逻辑，将数据通过 setData 发送到渲染层，举个例子：\n// packages/loc/city-select/city-select.js async query(keyword) { this.loading(true); let cities = []; let isError = false; try { // 搜索词非空则进行搜索  if (keyword) { const res = await suggestCityList({ query: keyword, }); cities = res.cities; } } catch (e) { isError = true; } this.setData({ searchText: keyword, searchResults: cities, isSuggestCityNetError: isError, }); this.loading(false); }, \u0026lt;!-- packages/loc/city-select/city-select.wxml --\u0026gt; \u0026lt;block wx:if=\u0026#34;{{searchResults.length !== 0}}\u0026#34;\u0026gt; \u0026lt;scroll-view scroll-y=\u0026#34;\u0026#34; bindscroll=\u0026#34;cityScroll\u0026#34; class=\u0026#34;search-results-list\u0026#34;\u0026gt; \u0026lt;view wx:for=\u0026#34;{{searchResults}}\u0026#34; wx:key=\u0026#34;{{index}}\u0026#34; class=\u0026#34;city-item\u0026#34; data-city=\u0026#34;{{item}}\u0026#34; bind:tap=\u0026#34;onTapSelectCity\u0026#34;\u0026gt; {{item.cityName}} \u0026lt;/view\u0026gt; \u0026lt;/scroll-view\u0026gt; \u0026lt;/block\u0026gt; 而渲染层解析我们的 WXML 和 WXSS，并结合数据渲染出页面。 小程序的运行环境 原生组件的出现 原生组件的出现，其实与 setData 的机制也有那么点关系，那么就当题外话一块补充下。\n频繁交互的性能 我们知道，用户的一次交互，如点击某个按钮，开发者的逻辑层要处理一些事情，然后再通过 setData 引起界面变化。这样的一个过程需要四次通信：\n  渲染层 -\u0026gt; Native（点击事件）。\n  Native -\u0026gt; 逻辑层（点击事件）。\n  逻辑层 -\u0026gt; Native（setData）。\n  Native -\u0026gt; 渲染层（setData）。\n  在一些强交互的场景（表单、canvas等），这样的操作流程会导致用户体验卡顿。\n引入原生组件 前面也说过，小程序是 Hybrid 应用，除了 Web 组件的渲染体系（上面讲到），还有由客户端原生参与组件（原生组件）的渲染。\n引入原生组件主要有 3 个好处：\n  绕过 setData、数据通信和重渲染流程，使渲染性能更好。\n  扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力。\n  体验更好，同时也减轻 WebView 的渲染工作。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用 WebView 线程，而交给更高效的客户端原生处理。\n  而原生组件的渲染过程：\n  组件被创建，包括组件属性会依次赋值。\n  组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y坐标）、宽高。\n  组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。\n  当位置或宽高发生变化时，组件会通知客户端做相应的调整。\n  简单来说，就是 原生组件在 WebView 这一层只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。\n有利必有弊，原生组件也是有限制的：\n  最主要的限制是一些 CSS 样式无法应用于原生组件\n  由于客户端渲染，原生组件的层级会比所有在 WebView 层渲染的普通组件要高 微信官方小程序同层渲染原理剖析 实际上，WebKit 内核并不感知原生组件的存在，因此并非所有的 WXSS 属性都可以在原生组件上生效。一般来说，定位 (position / margin / padding) 、尺寸 (width / height) 、transform (scale / rotate / translate) 以及层级 (z-index) 相关的属性均可生效，在原生组件外部的属性 (如 shadow、border) 一般也会生效。但如需对组件做裁剪则可能会失败，例如：border-radius 属性应用在父节点不会产生圆角效果。\n  基础库功能\n基础库除了处理 VD 的渲染问题，它还包括内置组件和逻辑层API，总的来说负责处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑。\n小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。在渲染层可以用各类组件组建界面的元素，在逻辑层可以用各类 API 来处理各种逻辑。\n同时，小程序的一些补充能力：自定义组件和插件，也有相应的基础代码，当然也需要添加到基础库里。\n所以我们可以看到，小程序的基础库主要是：\n  提供 VD 渲染机制相关基础代码。（Exparser 框架）\n  提供封装后的内置组件。\n  提供逻辑层的 API。\n  提供其他补充能力（自定义组件和插件等）的基础代码。\n  Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。 Exparser 特点包括：\n   基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。\n  可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。\n  e高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。\n   内置组件 小程序基于 Exparser 框架，内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。\n内置组件在小程序框架里的定义是：在小程序架构里无法实现或者实现不好某类功能，使用组件内置到小程序框架里。常见包括：\n  开放类组件：如 open-data 组件提供展示群名称、用户信息等微信体系下的隐私信息，有 button 组件里 open-type 属性所提供分享、跳转 App 等敏感操作的能力\n  视图容器类组件：如 movable-view 这种因双线程模型导致手势识别不好实现的组件（在双线程模型中，触摸事件从渲染层发出，派发到逻辑层，这中间是有一定的延时而导致视图跟随手指运动这类交互变得有些卡顿）\n  API 宿主环境提供了丰富的API，可以很方便调起微信提供的能力。小程序提供的 API 按照功能主要分为几大类：网络、媒体、文件、数据缓存、位置、设备、界面、界面节点信息还有一些特殊的开放接口。\n例如：获取本地缓存信息，获取系统信息，调起微信支付等等。\n自定义组件 自定义组件是开发者可以自行扩充的组件。开发者可以将常用的节点树结构提取成自定义组件，实现代码复用。例如上文截图中的midas-simple打点组件。\n在使用自定义组件的小程序页面中，Exparser 将接管所有的自定义组件注册与实例化。以 Component 为例：\n  在小程序启动时，构造器会将开发者设置的 properties、data、methods 等定义段，写入 Exparser 的组件注册表中。\n  这个组件在被其它组件引用时，就可以根据这些注册信息来创建自定义组件的实例。\n  Page 构造器的大体运行流程与之相仿，只是参数形式不一样。这样每个页面就有一个与之对应的组件，称为“页面根组件”。在初始化页面时，Exparser 会创建出页面根组件的一个实例，用到的其他组件也会响应创建组件实例（这是一个递归的过程）。\n插件 插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。\n插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。\n插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。\n基础库机制 基础库的载入 在开发网页时，经常会引用很多开源的 JS 库，在使用到这些库所提供的 API 前，我们需要先在业务代码前边引入这些库。\n同样道理，我们需要在启动 APP 之前载入基础库，接着再载入业务代码。由于小程序的渲染层和逻辑层是两个线程管理，而我们 一般说起基础库，也通常包括 WebView 基础库（渲染层），和 AppService 基础库（逻辑层）。\n显然，所有小程序在微信客户端打开的时候，都需要注入相同的基础库。所以，小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。\n将基础库内置在微信客户端，有两个好处：\n降低业务小程序的代码包大小。\n可以单独修复基础库中的Bug，无需修改到业务小程序的代码包。\n小程序的启动 在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。这里就包括了逻辑层和渲染层分别的初始化以及公共库的注入。 在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。 基础库更新 为了避免新版本的基础库给线上小程序带来未知的影响，微信客户端都是携带 上一个稳定版 的基础库发布的。\n在新版本客户端发布后，再通过后台灰度新版本基础库，灰度时长一般为 12 ～ 24 小时，在灰度结束后，用户设备上才会有新版本的基础库。\n以微信 6.5.8 为例，客户端在发布时携带的是 1.1.1 基础库（6.5.7 上已全量的稳定版）发布，在 6.5.8 发布后，我们再通过后台灰度 1.2.0 基础库。\n查看基础库版本分布\n基础库与客户端之间的关系 小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端。通常：\n第 1（major）、2（minor）位版本号更新通常需要依赖新版本的客户端，如：基础库 v2.1.3 运行在 v6.6.7 客户端，基础库 v2.2.0 需要 v6.7.0 客户端。\n第 3（patch） 位版本号的更新一般不需要依赖客户端更新，如：基础库v2.1.0 ~ v2.1.3 都运行在 v6.6.7 客户端，新版本发布会覆盖旧版本。\n关于基础库的兼容方法，可以查看「兼容处理」章节。\n基础库更新日志：https://developers.weixin.qq.com/miniprogram/dev/framework/release/\n参考资料：\n小程序的底层框架\n解剖小程序的 setData\n小程序自定义组件知多少\n神奇的Shadow DOM\n小程序没有 DOM 接口，原因竟然是……？\n小程序同层渲染原理剖析\n关于小程序的基础库\n2.4 JavaScript 脚本\n","date":"0001-01-01T00:00:00Z","permalink":"https://observerzq.github.io/ObzerverZQ.github.io/p/","title":""}]