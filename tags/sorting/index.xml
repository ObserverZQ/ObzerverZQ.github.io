<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sorting on Observer的小家</title>
    <link>https://observerzq.github.io/ObzerverZQ.github.io/tags/sorting/</link>
    <description>Recent content in sorting on Observer的小家</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Feb 2021 19:11:26 +0800</lastBuildDate><atom:link href="https://observerzq.github.io/ObzerverZQ.github.io/tags/sorting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript实现常见排序算法</title>
      <link>https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 26 Feb 2021 19:11:26 +0800</pubDate>
      
      <guid>https://observerzq.github.io/ObzerverZQ.github.io/p/javascript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>冒泡排序 基本思路：从左至右遍历数组，取一个指针指向第一个元素，与下一个元素比较，若该元素更大则前后交换位置，然后指针取下一位，与后一位进行比较，继续这样的循环，这样一轮下来会使得最大值放在数组的末尾，类似吐泡泡一样。之后重新开始循环上述过程，将第二大的元素放在倒数第二位。
function bubbleSort(array) { let isSorted = true; let len = array.length; for (let i = 0; i &amp;lt; len; i ++) { for (let j = 0; (j &amp;lt; len - i - 1); j++) { if (array[j] &amp;gt; array[j + 1]) { isSorted = false; [array[j], array[j + 1]] = [array[j + 1], array[j]]; } } if (isSorted) { break; } else { isSorted = true; } } return array; } 时间复杂度上，最好情况是O(n)，即数组已经完全排好序，后一个元素永远比前一个元素大，不需要冒泡，只需要遍历一次，平均和最坏情况是O(n2)。</description>
    </item>
    
  </channel>
</rss>
